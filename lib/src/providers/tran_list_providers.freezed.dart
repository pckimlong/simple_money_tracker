// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'tran_list_providers.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$TranDateAndIndex {
  DateTime get date => throw _privateConstructorUsedError;
  int get index => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $TranDateAndIndexCopyWith<TranDateAndIndex> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TranDateAndIndexCopyWith<$Res> {
  factory $TranDateAndIndexCopyWith(
          TranDateAndIndex value, $Res Function(TranDateAndIndex) then) =
      _$TranDateAndIndexCopyWithImpl<$Res>;
  $Res call({DateTime date, int index});
}

/// @nodoc
class _$TranDateAndIndexCopyWithImpl<$Res>
    implements $TranDateAndIndexCopyWith<$Res> {
  _$TranDateAndIndexCopyWithImpl(this._value, this._then);

  final TranDateAndIndex _value;
  // ignore: unused_field
  final $Res Function(TranDateAndIndex) _then;

  @override
  $Res call({
    Object? date = freezed,
    Object? index = freezed,
  }) {
    return _then(_value.copyWith(
      date: date == freezed
          ? _value.date
          : date // ignore: cast_nullable_to_non_nullable
              as DateTime,
      index: index == freezed
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$$_TranDateAndIndexCopyWith<$Res>
    implements $TranDateAndIndexCopyWith<$Res> {
  factory _$$_TranDateAndIndexCopyWith(
          _$_TranDateAndIndex value, $Res Function(_$_TranDateAndIndex) then) =
      __$$_TranDateAndIndexCopyWithImpl<$Res>;
  @override
  $Res call({DateTime date, int index});
}

/// @nodoc
class __$$_TranDateAndIndexCopyWithImpl<$Res>
    extends _$TranDateAndIndexCopyWithImpl<$Res>
    implements _$$_TranDateAndIndexCopyWith<$Res> {
  __$$_TranDateAndIndexCopyWithImpl(
      _$_TranDateAndIndex _value, $Res Function(_$_TranDateAndIndex) _then)
      : super(_value, (v) => _then(v as _$_TranDateAndIndex));

  @override
  _$_TranDateAndIndex get _value => super._value as _$_TranDateAndIndex;

  @override
  $Res call({
    Object? date = freezed,
    Object? index = freezed,
  }) {
    return _then(_$_TranDateAndIndex(
      date: date == freezed
          ? _value.date
          : date // ignore: cast_nullable_to_non_nullable
              as DateTime,
      index: index == freezed
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_TranDateAndIndex implements _TranDateAndIndex {
  _$_TranDateAndIndex({required this.date, required this.index});

  @override
  final DateTime date;
  @override
  final int index;

  @override
  String toString() {
    return 'TranDateAndIndex(date: $date, index: $index)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TranDateAndIndex &&
            const DeepCollectionEquality().equals(other.date, date) &&
            const DeepCollectionEquality().equals(other.index, index));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(date),
      const DeepCollectionEquality().hash(index));

  @JsonKey(ignore: true)
  @override
  _$$_TranDateAndIndexCopyWith<_$_TranDateAndIndex> get copyWith =>
      __$$_TranDateAndIndexCopyWithImpl<_$_TranDateAndIndex>(this, _$identity);
}

abstract class _TranDateAndIndex implements TranDateAndIndex {
  factory _TranDateAndIndex(
      {required final DateTime date,
      required final int index}) = _$_TranDateAndIndex;

  @override
  DateTime get date;
  @override
  int get index;
  @override
  @JsonKey(ignore: true)
  _$$_TranDateAndIndexCopyWith<_$_TranDateAndIndex> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ExpanseIncome {
  double get expense => throw _privateConstructorUsedError;
  double get income => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ExpanseIncomeCopyWith<ExpanseIncome> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExpanseIncomeCopyWith<$Res> {
  factory $ExpanseIncomeCopyWith(
          ExpanseIncome value, $Res Function(ExpanseIncome) then) =
      _$ExpanseIncomeCopyWithImpl<$Res>;
  $Res call({double expense, double income});
}

/// @nodoc
class _$ExpanseIncomeCopyWithImpl<$Res>
    implements $ExpanseIncomeCopyWith<$Res> {
  _$ExpanseIncomeCopyWithImpl(this._value, this._then);

  final ExpanseIncome _value;
  // ignore: unused_field
  final $Res Function(ExpanseIncome) _then;

  @override
  $Res call({
    Object? expense = freezed,
    Object? income = freezed,
  }) {
    return _then(_value.copyWith(
      expense: expense == freezed
          ? _value.expense
          : expense // ignore: cast_nullable_to_non_nullable
              as double,
      income: income == freezed
          ? _value.income
          : income // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
abstract class _$$_ExpanseIncomeCopyWith<$Res>
    implements $ExpanseIncomeCopyWith<$Res> {
  factory _$$_ExpanseIncomeCopyWith(
          _$_ExpanseIncome value, $Res Function(_$_ExpanseIncome) then) =
      __$$_ExpanseIncomeCopyWithImpl<$Res>;
  @override
  $Res call({double expense, double income});
}

/// @nodoc
class __$$_ExpanseIncomeCopyWithImpl<$Res>
    extends _$ExpanseIncomeCopyWithImpl<$Res>
    implements _$$_ExpanseIncomeCopyWith<$Res> {
  __$$_ExpanseIncomeCopyWithImpl(
      _$_ExpanseIncome _value, $Res Function(_$_ExpanseIncome) _then)
      : super(_value, (v) => _then(v as _$_ExpanseIncome));

  @override
  _$_ExpanseIncome get _value => super._value as _$_ExpanseIncome;

  @override
  $Res call({
    Object? expense = freezed,
    Object? income = freezed,
  }) {
    return _then(_$_ExpanseIncome(
      expense: expense == freezed
          ? _value.expense
          : expense // ignore: cast_nullable_to_non_nullable
              as double,
      income: income == freezed
          ? _value.income
          : income // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$_ExpanseIncome implements _ExpanseIncome {
  _$_ExpanseIncome({required this.expense, required this.income});

  @override
  final double expense;
  @override
  final double income;

  @override
  String toString() {
    return 'ExpanseIncome(expense: $expense, income: $income)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ExpanseIncome &&
            const DeepCollectionEquality().equals(other.expense, expense) &&
            const DeepCollectionEquality().equals(other.income, income));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(expense),
      const DeepCollectionEquality().hash(income));

  @JsonKey(ignore: true)
  @override
  _$$_ExpanseIncomeCopyWith<_$_ExpanseIncome> get copyWith =>
      __$$_ExpanseIncomeCopyWithImpl<_$_ExpanseIncome>(this, _$identity);
}

abstract class _ExpanseIncome implements ExpanseIncome {
  factory _ExpanseIncome(
      {required final double expense,
      required final double income}) = _$_ExpanseIncome;

  @override
  double get expense;
  @override
  double get income;
  @override
  @JsonKey(ignore: true)
  _$$_ExpanseIncomeCopyWith<_$_ExpanseIncome> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$TranFilterState {
  DateTime get startedDate => throw _privateConstructorUsedError;
  DateTime get endedDate => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $TranFilterStateCopyWith<TranFilterState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TranFilterStateCopyWith<$Res> {
  factory $TranFilterStateCopyWith(
          TranFilterState value, $Res Function(TranFilterState) then) =
      _$TranFilterStateCopyWithImpl<$Res>;
  $Res call({DateTime startedDate, DateTime endedDate});
}

/// @nodoc
class _$TranFilterStateCopyWithImpl<$Res>
    implements $TranFilterStateCopyWith<$Res> {
  _$TranFilterStateCopyWithImpl(this._value, this._then);

  final TranFilterState _value;
  // ignore: unused_field
  final $Res Function(TranFilterState) _then;

  @override
  $Res call({
    Object? startedDate = freezed,
    Object? endedDate = freezed,
  }) {
    return _then(_value.copyWith(
      startedDate: startedDate == freezed
          ? _value.startedDate
          : startedDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
      endedDate: endedDate == freezed
          ? _value.endedDate
          : endedDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc
abstract class _$$_TranFilterStateCopyWith<$Res>
    implements $TranFilterStateCopyWith<$Res> {
  factory _$$_TranFilterStateCopyWith(
          _$_TranFilterState value, $Res Function(_$_TranFilterState) then) =
      __$$_TranFilterStateCopyWithImpl<$Res>;
  @override
  $Res call({DateTime startedDate, DateTime endedDate});
}

/// @nodoc
class __$$_TranFilterStateCopyWithImpl<$Res>
    extends _$TranFilterStateCopyWithImpl<$Res>
    implements _$$_TranFilterStateCopyWith<$Res> {
  __$$_TranFilterStateCopyWithImpl(
      _$_TranFilterState _value, $Res Function(_$_TranFilterState) _then)
      : super(_value, (v) => _then(v as _$_TranFilterState));

  @override
  _$_TranFilterState get _value => super._value as _$_TranFilterState;

  @override
  $Res call({
    Object? startedDate = freezed,
    Object? endedDate = freezed,
  }) {
    return _then(_$_TranFilterState(
      startedDate: startedDate == freezed
          ? _value.startedDate
          : startedDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
      endedDate: endedDate == freezed
          ? _value.endedDate
          : endedDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc

class _$_TranFilterState implements _TranFilterState {
  _$_TranFilterState({required this.startedDate, required this.endedDate});

  @override
  final DateTime startedDate;
  @override
  final DateTime endedDate;

  @override
  String toString() {
    return 'TranFilterState(startedDate: $startedDate, endedDate: $endedDate)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TranFilterState &&
            const DeepCollectionEquality()
                .equals(other.startedDate, startedDate) &&
            const DeepCollectionEquality().equals(other.endedDate, endedDate));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(startedDate),
      const DeepCollectionEquality().hash(endedDate));

  @JsonKey(ignore: true)
  @override
  _$$_TranFilterStateCopyWith<_$_TranFilterState> get copyWith =>
      __$$_TranFilterStateCopyWithImpl<_$_TranFilterState>(this, _$identity);
}

abstract class _TranFilterState implements TranFilterState {
  factory _TranFilterState(
      {required final DateTime startedDate,
      required final DateTime endedDate}) = _$_TranFilterState;

  @override
  DateTime get startedDate;
  @override
  DateTime get endedDate;
  @override
  @JsonKey(ignore: true)
  _$$_TranFilterStateCopyWith<_$_TranFilterState> get copyWith =>
      throw _privateConstructorUsedError;
}
