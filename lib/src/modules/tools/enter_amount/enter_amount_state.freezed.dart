// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'enter_amount_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$EnterAmountEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() backspacePress,
    required TResult Function() clearPress,
    required TResult Function() dotPress,
    required TResult Function() equalPress,
    required TResult Function(int number) numberPress,
    required TResult Function(CalculatorItem calOperator) operatorPress,
    required TResult Function() threeZeroPress,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? backspacePress,
    TResult Function()? clearPress,
    TResult Function()? dotPress,
    TResult Function()? equalPress,
    TResult Function(int number)? numberPress,
    TResult Function(CalculatorItem calOperator)? operatorPress,
    TResult Function()? threeZeroPress,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? backspacePress,
    TResult Function()? clearPress,
    TResult Function()? dotPress,
    TResult Function()? equalPress,
    TResult Function(int number)? numberPress,
    TResult Function(CalculatorItem calOperator)? operatorPress,
    TResult Function()? threeZeroPress,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_BackspacePress value) backspacePress,
    required TResult Function(_ClearPress value) clearPress,
    required TResult Function(_DotPress value) dotPress,
    required TResult Function(_EqualPress value) equalPress,
    required TResult Function(_NumberPress value) numberPress,
    required TResult Function(_OperatorPress value) operatorPress,
    required TResult Function(_ThreeZeroPress value) threeZeroPress,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_BackspacePress value)? backspacePress,
    TResult Function(_ClearPress value)? clearPress,
    TResult Function(_DotPress value)? dotPress,
    TResult Function(_EqualPress value)? equalPress,
    TResult Function(_NumberPress value)? numberPress,
    TResult Function(_OperatorPress value)? operatorPress,
    TResult Function(_ThreeZeroPress value)? threeZeroPress,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_BackspacePress value)? backspacePress,
    TResult Function(_ClearPress value)? clearPress,
    TResult Function(_DotPress value)? dotPress,
    TResult Function(_EqualPress value)? equalPress,
    TResult Function(_NumberPress value)? numberPress,
    TResult Function(_OperatorPress value)? operatorPress,
    TResult Function(_ThreeZeroPress value)? threeZeroPress,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EnterAmountEventCopyWith<$Res> {
  factory $EnterAmountEventCopyWith(
          EnterAmountEvent value, $Res Function(EnterAmountEvent) then) =
      _$EnterAmountEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$EnterAmountEventCopyWithImpl<$Res>
    implements $EnterAmountEventCopyWith<$Res> {
  _$EnterAmountEventCopyWithImpl(this._value, this._then);

  final EnterAmountEvent _value;
  // ignore: unused_field
  final $Res Function(EnterAmountEvent) _then;
}

/// @nodoc
abstract class _$$_BackspacePressCopyWith<$Res> {
  factory _$$_BackspacePressCopyWith(
          _$_BackspacePress value, $Res Function(_$_BackspacePress) then) =
      __$$_BackspacePressCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_BackspacePressCopyWithImpl<$Res>
    extends _$EnterAmountEventCopyWithImpl<$Res>
    implements _$$_BackspacePressCopyWith<$Res> {
  __$$_BackspacePressCopyWithImpl(
      _$_BackspacePress _value, $Res Function(_$_BackspacePress) _then)
      : super(_value, (v) => _then(v as _$_BackspacePress));

  @override
  _$_BackspacePress get _value => super._value as _$_BackspacePress;
}

/// @nodoc

class _$_BackspacePress implements _BackspacePress {
  const _$_BackspacePress();

  @override
  String toString() {
    return 'EnterAmountEvent.backspacePress()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_BackspacePress);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() backspacePress,
    required TResult Function() clearPress,
    required TResult Function() dotPress,
    required TResult Function() equalPress,
    required TResult Function(int number) numberPress,
    required TResult Function(CalculatorItem calOperator) operatorPress,
    required TResult Function() threeZeroPress,
  }) {
    return backspacePress();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? backspacePress,
    TResult Function()? clearPress,
    TResult Function()? dotPress,
    TResult Function()? equalPress,
    TResult Function(int number)? numberPress,
    TResult Function(CalculatorItem calOperator)? operatorPress,
    TResult Function()? threeZeroPress,
  }) {
    return backspacePress?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? backspacePress,
    TResult Function()? clearPress,
    TResult Function()? dotPress,
    TResult Function()? equalPress,
    TResult Function(int number)? numberPress,
    TResult Function(CalculatorItem calOperator)? operatorPress,
    TResult Function()? threeZeroPress,
    required TResult orElse(),
  }) {
    if (backspacePress != null) {
      return backspacePress();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_BackspacePress value) backspacePress,
    required TResult Function(_ClearPress value) clearPress,
    required TResult Function(_DotPress value) dotPress,
    required TResult Function(_EqualPress value) equalPress,
    required TResult Function(_NumberPress value) numberPress,
    required TResult Function(_OperatorPress value) operatorPress,
    required TResult Function(_ThreeZeroPress value) threeZeroPress,
  }) {
    return backspacePress(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_BackspacePress value)? backspacePress,
    TResult Function(_ClearPress value)? clearPress,
    TResult Function(_DotPress value)? dotPress,
    TResult Function(_EqualPress value)? equalPress,
    TResult Function(_NumberPress value)? numberPress,
    TResult Function(_OperatorPress value)? operatorPress,
    TResult Function(_ThreeZeroPress value)? threeZeroPress,
  }) {
    return backspacePress?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_BackspacePress value)? backspacePress,
    TResult Function(_ClearPress value)? clearPress,
    TResult Function(_DotPress value)? dotPress,
    TResult Function(_EqualPress value)? equalPress,
    TResult Function(_NumberPress value)? numberPress,
    TResult Function(_OperatorPress value)? operatorPress,
    TResult Function(_ThreeZeroPress value)? threeZeroPress,
    required TResult orElse(),
  }) {
    if (backspacePress != null) {
      return backspacePress(this);
    }
    return orElse();
  }
}

abstract class _BackspacePress implements EnterAmountEvent {
  const factory _BackspacePress() = _$_BackspacePress;
}

/// @nodoc
abstract class _$$_ClearPressCopyWith<$Res> {
  factory _$$_ClearPressCopyWith(
          _$_ClearPress value, $Res Function(_$_ClearPress) then) =
      __$$_ClearPressCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_ClearPressCopyWithImpl<$Res>
    extends _$EnterAmountEventCopyWithImpl<$Res>
    implements _$$_ClearPressCopyWith<$Res> {
  __$$_ClearPressCopyWithImpl(
      _$_ClearPress _value, $Res Function(_$_ClearPress) _then)
      : super(_value, (v) => _then(v as _$_ClearPress));

  @override
  _$_ClearPress get _value => super._value as _$_ClearPress;
}

/// @nodoc

class _$_ClearPress implements _ClearPress {
  const _$_ClearPress();

  @override
  String toString() {
    return 'EnterAmountEvent.clearPress()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_ClearPress);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() backspacePress,
    required TResult Function() clearPress,
    required TResult Function() dotPress,
    required TResult Function() equalPress,
    required TResult Function(int number) numberPress,
    required TResult Function(CalculatorItem calOperator) operatorPress,
    required TResult Function() threeZeroPress,
  }) {
    return clearPress();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? backspacePress,
    TResult Function()? clearPress,
    TResult Function()? dotPress,
    TResult Function()? equalPress,
    TResult Function(int number)? numberPress,
    TResult Function(CalculatorItem calOperator)? operatorPress,
    TResult Function()? threeZeroPress,
  }) {
    return clearPress?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? backspacePress,
    TResult Function()? clearPress,
    TResult Function()? dotPress,
    TResult Function()? equalPress,
    TResult Function(int number)? numberPress,
    TResult Function(CalculatorItem calOperator)? operatorPress,
    TResult Function()? threeZeroPress,
    required TResult orElse(),
  }) {
    if (clearPress != null) {
      return clearPress();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_BackspacePress value) backspacePress,
    required TResult Function(_ClearPress value) clearPress,
    required TResult Function(_DotPress value) dotPress,
    required TResult Function(_EqualPress value) equalPress,
    required TResult Function(_NumberPress value) numberPress,
    required TResult Function(_OperatorPress value) operatorPress,
    required TResult Function(_ThreeZeroPress value) threeZeroPress,
  }) {
    return clearPress(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_BackspacePress value)? backspacePress,
    TResult Function(_ClearPress value)? clearPress,
    TResult Function(_DotPress value)? dotPress,
    TResult Function(_EqualPress value)? equalPress,
    TResult Function(_NumberPress value)? numberPress,
    TResult Function(_OperatorPress value)? operatorPress,
    TResult Function(_ThreeZeroPress value)? threeZeroPress,
  }) {
    return clearPress?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_BackspacePress value)? backspacePress,
    TResult Function(_ClearPress value)? clearPress,
    TResult Function(_DotPress value)? dotPress,
    TResult Function(_EqualPress value)? equalPress,
    TResult Function(_NumberPress value)? numberPress,
    TResult Function(_OperatorPress value)? operatorPress,
    TResult Function(_ThreeZeroPress value)? threeZeroPress,
    required TResult orElse(),
  }) {
    if (clearPress != null) {
      return clearPress(this);
    }
    return orElse();
  }
}

abstract class _ClearPress implements EnterAmountEvent {
  const factory _ClearPress() = _$_ClearPress;
}

/// @nodoc
abstract class _$$_DotPressCopyWith<$Res> {
  factory _$$_DotPressCopyWith(
          _$_DotPress value, $Res Function(_$_DotPress) then) =
      __$$_DotPressCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_DotPressCopyWithImpl<$Res>
    extends _$EnterAmountEventCopyWithImpl<$Res>
    implements _$$_DotPressCopyWith<$Res> {
  __$$_DotPressCopyWithImpl(
      _$_DotPress _value, $Res Function(_$_DotPress) _then)
      : super(_value, (v) => _then(v as _$_DotPress));

  @override
  _$_DotPress get _value => super._value as _$_DotPress;
}

/// @nodoc

class _$_DotPress implements _DotPress {
  const _$_DotPress();

  @override
  String toString() {
    return 'EnterAmountEvent.dotPress()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_DotPress);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() backspacePress,
    required TResult Function() clearPress,
    required TResult Function() dotPress,
    required TResult Function() equalPress,
    required TResult Function(int number) numberPress,
    required TResult Function(CalculatorItem calOperator) operatorPress,
    required TResult Function() threeZeroPress,
  }) {
    return dotPress();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? backspacePress,
    TResult Function()? clearPress,
    TResult Function()? dotPress,
    TResult Function()? equalPress,
    TResult Function(int number)? numberPress,
    TResult Function(CalculatorItem calOperator)? operatorPress,
    TResult Function()? threeZeroPress,
  }) {
    return dotPress?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? backspacePress,
    TResult Function()? clearPress,
    TResult Function()? dotPress,
    TResult Function()? equalPress,
    TResult Function(int number)? numberPress,
    TResult Function(CalculatorItem calOperator)? operatorPress,
    TResult Function()? threeZeroPress,
    required TResult orElse(),
  }) {
    if (dotPress != null) {
      return dotPress();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_BackspacePress value) backspacePress,
    required TResult Function(_ClearPress value) clearPress,
    required TResult Function(_DotPress value) dotPress,
    required TResult Function(_EqualPress value) equalPress,
    required TResult Function(_NumberPress value) numberPress,
    required TResult Function(_OperatorPress value) operatorPress,
    required TResult Function(_ThreeZeroPress value) threeZeroPress,
  }) {
    return dotPress(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_BackspacePress value)? backspacePress,
    TResult Function(_ClearPress value)? clearPress,
    TResult Function(_DotPress value)? dotPress,
    TResult Function(_EqualPress value)? equalPress,
    TResult Function(_NumberPress value)? numberPress,
    TResult Function(_OperatorPress value)? operatorPress,
    TResult Function(_ThreeZeroPress value)? threeZeroPress,
  }) {
    return dotPress?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_BackspacePress value)? backspacePress,
    TResult Function(_ClearPress value)? clearPress,
    TResult Function(_DotPress value)? dotPress,
    TResult Function(_EqualPress value)? equalPress,
    TResult Function(_NumberPress value)? numberPress,
    TResult Function(_OperatorPress value)? operatorPress,
    TResult Function(_ThreeZeroPress value)? threeZeroPress,
    required TResult orElse(),
  }) {
    if (dotPress != null) {
      return dotPress(this);
    }
    return orElse();
  }
}

abstract class _DotPress implements EnterAmountEvent {
  const factory _DotPress() = _$_DotPress;
}

/// @nodoc
abstract class _$$_EqualPressCopyWith<$Res> {
  factory _$$_EqualPressCopyWith(
          _$_EqualPress value, $Res Function(_$_EqualPress) then) =
      __$$_EqualPressCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_EqualPressCopyWithImpl<$Res>
    extends _$EnterAmountEventCopyWithImpl<$Res>
    implements _$$_EqualPressCopyWith<$Res> {
  __$$_EqualPressCopyWithImpl(
      _$_EqualPress _value, $Res Function(_$_EqualPress) _then)
      : super(_value, (v) => _then(v as _$_EqualPress));

  @override
  _$_EqualPress get _value => super._value as _$_EqualPress;
}

/// @nodoc

class _$_EqualPress implements _EqualPress {
  const _$_EqualPress();

  @override
  String toString() {
    return 'EnterAmountEvent.equalPress()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_EqualPress);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() backspacePress,
    required TResult Function() clearPress,
    required TResult Function() dotPress,
    required TResult Function() equalPress,
    required TResult Function(int number) numberPress,
    required TResult Function(CalculatorItem calOperator) operatorPress,
    required TResult Function() threeZeroPress,
  }) {
    return equalPress();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? backspacePress,
    TResult Function()? clearPress,
    TResult Function()? dotPress,
    TResult Function()? equalPress,
    TResult Function(int number)? numberPress,
    TResult Function(CalculatorItem calOperator)? operatorPress,
    TResult Function()? threeZeroPress,
  }) {
    return equalPress?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? backspacePress,
    TResult Function()? clearPress,
    TResult Function()? dotPress,
    TResult Function()? equalPress,
    TResult Function(int number)? numberPress,
    TResult Function(CalculatorItem calOperator)? operatorPress,
    TResult Function()? threeZeroPress,
    required TResult orElse(),
  }) {
    if (equalPress != null) {
      return equalPress();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_BackspacePress value) backspacePress,
    required TResult Function(_ClearPress value) clearPress,
    required TResult Function(_DotPress value) dotPress,
    required TResult Function(_EqualPress value) equalPress,
    required TResult Function(_NumberPress value) numberPress,
    required TResult Function(_OperatorPress value) operatorPress,
    required TResult Function(_ThreeZeroPress value) threeZeroPress,
  }) {
    return equalPress(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_BackspacePress value)? backspacePress,
    TResult Function(_ClearPress value)? clearPress,
    TResult Function(_DotPress value)? dotPress,
    TResult Function(_EqualPress value)? equalPress,
    TResult Function(_NumberPress value)? numberPress,
    TResult Function(_OperatorPress value)? operatorPress,
    TResult Function(_ThreeZeroPress value)? threeZeroPress,
  }) {
    return equalPress?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_BackspacePress value)? backspacePress,
    TResult Function(_ClearPress value)? clearPress,
    TResult Function(_DotPress value)? dotPress,
    TResult Function(_EqualPress value)? equalPress,
    TResult Function(_NumberPress value)? numberPress,
    TResult Function(_OperatorPress value)? operatorPress,
    TResult Function(_ThreeZeroPress value)? threeZeroPress,
    required TResult orElse(),
  }) {
    if (equalPress != null) {
      return equalPress(this);
    }
    return orElse();
  }
}

abstract class _EqualPress implements EnterAmountEvent {
  const factory _EqualPress() = _$_EqualPress;
}

/// @nodoc
abstract class _$$_NumberPressCopyWith<$Res> {
  factory _$$_NumberPressCopyWith(
          _$_NumberPress value, $Res Function(_$_NumberPress) then) =
      __$$_NumberPressCopyWithImpl<$Res>;
  $Res call({int number});
}

/// @nodoc
class __$$_NumberPressCopyWithImpl<$Res>
    extends _$EnterAmountEventCopyWithImpl<$Res>
    implements _$$_NumberPressCopyWith<$Res> {
  __$$_NumberPressCopyWithImpl(
      _$_NumberPress _value, $Res Function(_$_NumberPress) _then)
      : super(_value, (v) => _then(v as _$_NumberPress));

  @override
  _$_NumberPress get _value => super._value as _$_NumberPress;

  @override
  $Res call({
    Object? number = freezed,
  }) {
    return _then(_$_NumberPress(
      number == freezed
          ? _value.number
          : number // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_NumberPress implements _NumberPress {
  const _$_NumberPress(this.number);

  @override
  final int number;

  @override
  String toString() {
    return 'EnterAmountEvent.numberPress(number: $number)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_NumberPress &&
            const DeepCollectionEquality().equals(other.number, number));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(number));

  @JsonKey(ignore: true)
  @override
  _$$_NumberPressCopyWith<_$_NumberPress> get copyWith =>
      __$$_NumberPressCopyWithImpl<_$_NumberPress>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() backspacePress,
    required TResult Function() clearPress,
    required TResult Function() dotPress,
    required TResult Function() equalPress,
    required TResult Function(int number) numberPress,
    required TResult Function(CalculatorItem calOperator) operatorPress,
    required TResult Function() threeZeroPress,
  }) {
    return numberPress(number);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? backspacePress,
    TResult Function()? clearPress,
    TResult Function()? dotPress,
    TResult Function()? equalPress,
    TResult Function(int number)? numberPress,
    TResult Function(CalculatorItem calOperator)? operatorPress,
    TResult Function()? threeZeroPress,
  }) {
    return numberPress?.call(number);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? backspacePress,
    TResult Function()? clearPress,
    TResult Function()? dotPress,
    TResult Function()? equalPress,
    TResult Function(int number)? numberPress,
    TResult Function(CalculatorItem calOperator)? operatorPress,
    TResult Function()? threeZeroPress,
    required TResult orElse(),
  }) {
    if (numberPress != null) {
      return numberPress(number);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_BackspacePress value) backspacePress,
    required TResult Function(_ClearPress value) clearPress,
    required TResult Function(_DotPress value) dotPress,
    required TResult Function(_EqualPress value) equalPress,
    required TResult Function(_NumberPress value) numberPress,
    required TResult Function(_OperatorPress value) operatorPress,
    required TResult Function(_ThreeZeroPress value) threeZeroPress,
  }) {
    return numberPress(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_BackspacePress value)? backspacePress,
    TResult Function(_ClearPress value)? clearPress,
    TResult Function(_DotPress value)? dotPress,
    TResult Function(_EqualPress value)? equalPress,
    TResult Function(_NumberPress value)? numberPress,
    TResult Function(_OperatorPress value)? operatorPress,
    TResult Function(_ThreeZeroPress value)? threeZeroPress,
  }) {
    return numberPress?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_BackspacePress value)? backspacePress,
    TResult Function(_ClearPress value)? clearPress,
    TResult Function(_DotPress value)? dotPress,
    TResult Function(_EqualPress value)? equalPress,
    TResult Function(_NumberPress value)? numberPress,
    TResult Function(_OperatorPress value)? operatorPress,
    TResult Function(_ThreeZeroPress value)? threeZeroPress,
    required TResult orElse(),
  }) {
    if (numberPress != null) {
      return numberPress(this);
    }
    return orElse();
  }
}

abstract class _NumberPress implements EnterAmountEvent {
  const factory _NumberPress(final int number) = _$_NumberPress;

  int get number;
  @JsonKey(ignore: true)
  _$$_NumberPressCopyWith<_$_NumberPress> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_OperatorPressCopyWith<$Res> {
  factory _$$_OperatorPressCopyWith(
          _$_OperatorPress value, $Res Function(_$_OperatorPress) then) =
      __$$_OperatorPressCopyWithImpl<$Res>;
  $Res call({CalculatorItem calOperator});

  $CalculatorItemCopyWith<$Res> get calOperator;
}

/// @nodoc
class __$$_OperatorPressCopyWithImpl<$Res>
    extends _$EnterAmountEventCopyWithImpl<$Res>
    implements _$$_OperatorPressCopyWith<$Res> {
  __$$_OperatorPressCopyWithImpl(
      _$_OperatorPress _value, $Res Function(_$_OperatorPress) _then)
      : super(_value, (v) => _then(v as _$_OperatorPress));

  @override
  _$_OperatorPress get _value => super._value as _$_OperatorPress;

  @override
  $Res call({
    Object? calOperator = freezed,
  }) {
    return _then(_$_OperatorPress(
      calOperator == freezed
          ? _value.calOperator
          : calOperator // ignore: cast_nullable_to_non_nullable
              as CalculatorItem,
    ));
  }

  @override
  $CalculatorItemCopyWith<$Res> get calOperator {
    return $CalculatorItemCopyWith<$Res>(_value.calOperator, (value) {
      return _then(_value.copyWith(calOperator: value));
    });
  }
}

/// @nodoc

class _$_OperatorPress implements _OperatorPress {
  const _$_OperatorPress(this.calOperator);

  @override
  final CalculatorItem calOperator;

  @override
  String toString() {
    return 'EnterAmountEvent.operatorPress(calOperator: $calOperator)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_OperatorPress &&
            const DeepCollectionEquality()
                .equals(other.calOperator, calOperator));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(calOperator));

  @JsonKey(ignore: true)
  @override
  _$$_OperatorPressCopyWith<_$_OperatorPress> get copyWith =>
      __$$_OperatorPressCopyWithImpl<_$_OperatorPress>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() backspacePress,
    required TResult Function() clearPress,
    required TResult Function() dotPress,
    required TResult Function() equalPress,
    required TResult Function(int number) numberPress,
    required TResult Function(CalculatorItem calOperator) operatorPress,
    required TResult Function() threeZeroPress,
  }) {
    return operatorPress(calOperator);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? backspacePress,
    TResult Function()? clearPress,
    TResult Function()? dotPress,
    TResult Function()? equalPress,
    TResult Function(int number)? numberPress,
    TResult Function(CalculatorItem calOperator)? operatorPress,
    TResult Function()? threeZeroPress,
  }) {
    return operatorPress?.call(calOperator);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? backspacePress,
    TResult Function()? clearPress,
    TResult Function()? dotPress,
    TResult Function()? equalPress,
    TResult Function(int number)? numberPress,
    TResult Function(CalculatorItem calOperator)? operatorPress,
    TResult Function()? threeZeroPress,
    required TResult orElse(),
  }) {
    if (operatorPress != null) {
      return operatorPress(calOperator);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_BackspacePress value) backspacePress,
    required TResult Function(_ClearPress value) clearPress,
    required TResult Function(_DotPress value) dotPress,
    required TResult Function(_EqualPress value) equalPress,
    required TResult Function(_NumberPress value) numberPress,
    required TResult Function(_OperatorPress value) operatorPress,
    required TResult Function(_ThreeZeroPress value) threeZeroPress,
  }) {
    return operatorPress(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_BackspacePress value)? backspacePress,
    TResult Function(_ClearPress value)? clearPress,
    TResult Function(_DotPress value)? dotPress,
    TResult Function(_EqualPress value)? equalPress,
    TResult Function(_NumberPress value)? numberPress,
    TResult Function(_OperatorPress value)? operatorPress,
    TResult Function(_ThreeZeroPress value)? threeZeroPress,
  }) {
    return operatorPress?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_BackspacePress value)? backspacePress,
    TResult Function(_ClearPress value)? clearPress,
    TResult Function(_DotPress value)? dotPress,
    TResult Function(_EqualPress value)? equalPress,
    TResult Function(_NumberPress value)? numberPress,
    TResult Function(_OperatorPress value)? operatorPress,
    TResult Function(_ThreeZeroPress value)? threeZeroPress,
    required TResult orElse(),
  }) {
    if (operatorPress != null) {
      return operatorPress(this);
    }
    return orElse();
  }
}

abstract class _OperatorPress implements EnterAmountEvent {
  const factory _OperatorPress(final CalculatorItem calOperator) =
      _$_OperatorPress;

  CalculatorItem get calOperator;
  @JsonKey(ignore: true)
  _$$_OperatorPressCopyWith<_$_OperatorPress> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_ThreeZeroPressCopyWith<$Res> {
  factory _$$_ThreeZeroPressCopyWith(
          _$_ThreeZeroPress value, $Res Function(_$_ThreeZeroPress) then) =
      __$$_ThreeZeroPressCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_ThreeZeroPressCopyWithImpl<$Res>
    extends _$EnterAmountEventCopyWithImpl<$Res>
    implements _$$_ThreeZeroPressCopyWith<$Res> {
  __$$_ThreeZeroPressCopyWithImpl(
      _$_ThreeZeroPress _value, $Res Function(_$_ThreeZeroPress) _then)
      : super(_value, (v) => _then(v as _$_ThreeZeroPress));

  @override
  _$_ThreeZeroPress get _value => super._value as _$_ThreeZeroPress;
}

/// @nodoc

class _$_ThreeZeroPress implements _ThreeZeroPress {
  const _$_ThreeZeroPress();

  @override
  String toString() {
    return 'EnterAmountEvent.threeZeroPress()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_ThreeZeroPress);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() backspacePress,
    required TResult Function() clearPress,
    required TResult Function() dotPress,
    required TResult Function() equalPress,
    required TResult Function(int number) numberPress,
    required TResult Function(CalculatorItem calOperator) operatorPress,
    required TResult Function() threeZeroPress,
  }) {
    return threeZeroPress();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? backspacePress,
    TResult Function()? clearPress,
    TResult Function()? dotPress,
    TResult Function()? equalPress,
    TResult Function(int number)? numberPress,
    TResult Function(CalculatorItem calOperator)? operatorPress,
    TResult Function()? threeZeroPress,
  }) {
    return threeZeroPress?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? backspacePress,
    TResult Function()? clearPress,
    TResult Function()? dotPress,
    TResult Function()? equalPress,
    TResult Function(int number)? numberPress,
    TResult Function(CalculatorItem calOperator)? operatorPress,
    TResult Function()? threeZeroPress,
    required TResult orElse(),
  }) {
    if (threeZeroPress != null) {
      return threeZeroPress();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_BackspacePress value) backspacePress,
    required TResult Function(_ClearPress value) clearPress,
    required TResult Function(_DotPress value) dotPress,
    required TResult Function(_EqualPress value) equalPress,
    required TResult Function(_NumberPress value) numberPress,
    required TResult Function(_OperatorPress value) operatorPress,
    required TResult Function(_ThreeZeroPress value) threeZeroPress,
  }) {
    return threeZeroPress(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_BackspacePress value)? backspacePress,
    TResult Function(_ClearPress value)? clearPress,
    TResult Function(_DotPress value)? dotPress,
    TResult Function(_EqualPress value)? equalPress,
    TResult Function(_NumberPress value)? numberPress,
    TResult Function(_OperatorPress value)? operatorPress,
    TResult Function(_ThreeZeroPress value)? threeZeroPress,
  }) {
    return threeZeroPress?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_BackspacePress value)? backspacePress,
    TResult Function(_ClearPress value)? clearPress,
    TResult Function(_DotPress value)? dotPress,
    TResult Function(_EqualPress value)? equalPress,
    TResult Function(_NumberPress value)? numberPress,
    TResult Function(_OperatorPress value)? operatorPress,
    TResult Function(_ThreeZeroPress value)? threeZeroPress,
    required TResult orElse(),
  }) {
    if (threeZeroPress != null) {
      return threeZeroPress(this);
    }
    return orElse();
  }
}

abstract class _ThreeZeroPress implements EnterAmountEvent {
  const factory _ThreeZeroPress() = _$_ThreeZeroPress;
}

/// @nodoc
mixin _$EnterAmountState {
  /// Calculate items for perfom calculate. eg 2+20-5*5
  /// When click = this will use to calculate value
  IList<CalculatorItem> get calItems => throw _privateConstructorUsedError;

  /// If value to calculate is incorrect
  bool get incorrecFormat => throw _privateConstructorUsedError;

  /// Value error message
  Option<String> get valueErrorMgs => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $EnterAmountStateCopyWith<EnterAmountState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EnterAmountStateCopyWith<$Res> {
  factory $EnterAmountStateCopyWith(
          EnterAmountState value, $Res Function(EnterAmountState) then) =
      _$EnterAmountStateCopyWithImpl<$Res>;
  $Res call(
      {IList<CalculatorItem> calItems,
      bool incorrecFormat,
      Option<String> valueErrorMgs});
}

/// @nodoc
class _$EnterAmountStateCopyWithImpl<$Res>
    implements $EnterAmountStateCopyWith<$Res> {
  _$EnterAmountStateCopyWithImpl(this._value, this._then);

  final EnterAmountState _value;
  // ignore: unused_field
  final $Res Function(EnterAmountState) _then;

  @override
  $Res call({
    Object? calItems = freezed,
    Object? incorrecFormat = freezed,
    Object? valueErrorMgs = freezed,
  }) {
    return _then(_value.copyWith(
      calItems: calItems == freezed
          ? _value.calItems
          : calItems // ignore: cast_nullable_to_non_nullable
              as IList<CalculatorItem>,
      incorrecFormat: incorrecFormat == freezed
          ? _value.incorrecFormat
          : incorrecFormat // ignore: cast_nullable_to_non_nullable
              as bool,
      valueErrorMgs: valueErrorMgs == freezed
          ? _value.valueErrorMgs
          : valueErrorMgs // ignore: cast_nullable_to_non_nullable
              as Option<String>,
    ));
  }
}

/// @nodoc
abstract class _$$_EnterAmountStateCopyWith<$Res>
    implements $EnterAmountStateCopyWith<$Res> {
  factory _$$_EnterAmountStateCopyWith(
          _$_EnterAmountState value, $Res Function(_$_EnterAmountState) then) =
      __$$_EnterAmountStateCopyWithImpl<$Res>;
  @override
  $Res call(
      {IList<CalculatorItem> calItems,
      bool incorrecFormat,
      Option<String> valueErrorMgs});
}

/// @nodoc
class __$$_EnterAmountStateCopyWithImpl<$Res>
    extends _$EnterAmountStateCopyWithImpl<$Res>
    implements _$$_EnterAmountStateCopyWith<$Res> {
  __$$_EnterAmountStateCopyWithImpl(
      _$_EnterAmountState _value, $Res Function(_$_EnterAmountState) _then)
      : super(_value, (v) => _then(v as _$_EnterAmountState));

  @override
  _$_EnterAmountState get _value => super._value as _$_EnterAmountState;

  @override
  $Res call({
    Object? calItems = freezed,
    Object? incorrecFormat = freezed,
    Object? valueErrorMgs = freezed,
  }) {
    return _then(_$_EnterAmountState(
      calItems: calItems == freezed
          ? _value.calItems
          : calItems // ignore: cast_nullable_to_non_nullable
              as IList<CalculatorItem>,
      incorrecFormat: incorrecFormat == freezed
          ? _value.incorrecFormat
          : incorrecFormat // ignore: cast_nullable_to_non_nullable
              as bool,
      valueErrorMgs: valueErrorMgs == freezed
          ? _value.valueErrorMgs
          : valueErrorMgs // ignore: cast_nullable_to_non_nullable
              as Option<String>,
    ));
  }
}

/// @nodoc

class _$_EnterAmountState extends _EnterAmountState {
  _$_EnterAmountState(
      {required this.calItems,
      required this.incorrecFormat,
      required this.valueErrorMgs})
      : super._();

  /// Calculate items for perfom calculate. eg 2+20-5*5
  /// When click = this will use to calculate value
  @override
  final IList<CalculatorItem> calItems;

  /// If value to calculate is incorrect
  @override
  final bool incorrecFormat;

  /// Value error message
  @override
  final Option<String> valueErrorMgs;

  @override
  String toString() {
    return 'EnterAmountState(calItems: $calItems, incorrecFormat: $incorrecFormat, valueErrorMgs: $valueErrorMgs)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_EnterAmountState &&
            const DeepCollectionEquality().equals(other.calItems, calItems) &&
            const DeepCollectionEquality()
                .equals(other.incorrecFormat, incorrecFormat) &&
            const DeepCollectionEquality()
                .equals(other.valueErrorMgs, valueErrorMgs));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(calItems),
      const DeepCollectionEquality().hash(incorrecFormat),
      const DeepCollectionEquality().hash(valueErrorMgs));

  @JsonKey(ignore: true)
  @override
  _$$_EnterAmountStateCopyWith<_$_EnterAmountState> get copyWith =>
      __$$_EnterAmountStateCopyWithImpl<_$_EnterAmountState>(this, _$identity);
}

abstract class _EnterAmountState extends EnterAmountState {
  factory _EnterAmountState(
      {required final IList<CalculatorItem> calItems,
      required final bool incorrecFormat,
      required final Option<String> valueErrorMgs}) = _$_EnterAmountState;
  _EnterAmountState._() : super._();

  @override

  /// Calculate items for perfom calculate. eg 2+20-5*5
  /// When click = this will use to calculate value
  IList<CalculatorItem> get calItems;
  @override

  /// If value to calculate is incorrect
  bool get incorrecFormat;
  @override

  /// Value error message
  Option<String> get valueErrorMgs;
  @override
  @JsonKey(ignore: true)
  _$$_EnterAmountStateCopyWith<_$_EnterAmountState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$CalculatorItem {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() add,
    required TResult Function() divide,
    required TResult Function() multiply,
    required TResult Function(String value) number,
    required TResult Function() substract,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? add,
    TResult Function()? divide,
    TResult Function()? multiply,
    TResult Function(String value)? number,
    TResult Function()? substract,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? add,
    TResult Function()? divide,
    TResult Function()? multiply,
    TResult Function(String value)? number,
    TResult Function()? substract,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Add value) add,
    required TResult Function(_Divide value) divide,
    required TResult Function(_Multiply value) multiply,
    required TResult Function(_Number value) number,
    required TResult Function(_Substract value) substract,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Add value)? add,
    TResult Function(_Divide value)? divide,
    TResult Function(_Multiply value)? multiply,
    TResult Function(_Number value)? number,
    TResult Function(_Substract value)? substract,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Add value)? add,
    TResult Function(_Divide value)? divide,
    TResult Function(_Multiply value)? multiply,
    TResult Function(_Number value)? number,
    TResult Function(_Substract value)? substract,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CalculatorItemCopyWith<$Res> {
  factory $CalculatorItemCopyWith(
          CalculatorItem value, $Res Function(CalculatorItem) then) =
      _$CalculatorItemCopyWithImpl<$Res>;
}

/// @nodoc
class _$CalculatorItemCopyWithImpl<$Res>
    implements $CalculatorItemCopyWith<$Res> {
  _$CalculatorItemCopyWithImpl(this._value, this._then);

  final CalculatorItem _value;
  // ignore: unused_field
  final $Res Function(CalculatorItem) _then;
}

/// @nodoc
abstract class _$$_AddCopyWith<$Res> {
  factory _$$_AddCopyWith(_$_Add value, $Res Function(_$_Add) then) =
      __$$_AddCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_AddCopyWithImpl<$Res> extends _$CalculatorItemCopyWithImpl<$Res>
    implements _$$_AddCopyWith<$Res> {
  __$$_AddCopyWithImpl(_$_Add _value, $Res Function(_$_Add) _then)
      : super(_value, (v) => _then(v as _$_Add));

  @override
  _$_Add get _value => super._value as _$_Add;
}

/// @nodoc

class _$_Add implements _Add {
  const _$_Add();

  @override
  String toString() {
    return 'CalculatorItem.add()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Add);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() add,
    required TResult Function() divide,
    required TResult Function() multiply,
    required TResult Function(String value) number,
    required TResult Function() substract,
  }) {
    return add();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? add,
    TResult Function()? divide,
    TResult Function()? multiply,
    TResult Function(String value)? number,
    TResult Function()? substract,
  }) {
    return add?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? add,
    TResult Function()? divide,
    TResult Function()? multiply,
    TResult Function(String value)? number,
    TResult Function()? substract,
    required TResult orElse(),
  }) {
    if (add != null) {
      return add();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Add value) add,
    required TResult Function(_Divide value) divide,
    required TResult Function(_Multiply value) multiply,
    required TResult Function(_Number value) number,
    required TResult Function(_Substract value) substract,
  }) {
    return add(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Add value)? add,
    TResult Function(_Divide value)? divide,
    TResult Function(_Multiply value)? multiply,
    TResult Function(_Number value)? number,
    TResult Function(_Substract value)? substract,
  }) {
    return add?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Add value)? add,
    TResult Function(_Divide value)? divide,
    TResult Function(_Multiply value)? multiply,
    TResult Function(_Number value)? number,
    TResult Function(_Substract value)? substract,
    required TResult orElse(),
  }) {
    if (add != null) {
      return add(this);
    }
    return orElse();
  }
}

abstract class _Add implements CalculatorItem {
  const factory _Add() = _$_Add;
}

/// @nodoc
abstract class _$$_DivideCopyWith<$Res> {
  factory _$$_DivideCopyWith(_$_Divide value, $Res Function(_$_Divide) then) =
      __$$_DivideCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_DivideCopyWithImpl<$Res> extends _$CalculatorItemCopyWithImpl<$Res>
    implements _$$_DivideCopyWith<$Res> {
  __$$_DivideCopyWithImpl(_$_Divide _value, $Res Function(_$_Divide) _then)
      : super(_value, (v) => _then(v as _$_Divide));

  @override
  _$_Divide get _value => super._value as _$_Divide;
}

/// @nodoc

class _$_Divide implements _Divide {
  const _$_Divide();

  @override
  String toString() {
    return 'CalculatorItem.divide()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Divide);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() add,
    required TResult Function() divide,
    required TResult Function() multiply,
    required TResult Function(String value) number,
    required TResult Function() substract,
  }) {
    return divide();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? add,
    TResult Function()? divide,
    TResult Function()? multiply,
    TResult Function(String value)? number,
    TResult Function()? substract,
  }) {
    return divide?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? add,
    TResult Function()? divide,
    TResult Function()? multiply,
    TResult Function(String value)? number,
    TResult Function()? substract,
    required TResult orElse(),
  }) {
    if (divide != null) {
      return divide();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Add value) add,
    required TResult Function(_Divide value) divide,
    required TResult Function(_Multiply value) multiply,
    required TResult Function(_Number value) number,
    required TResult Function(_Substract value) substract,
  }) {
    return divide(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Add value)? add,
    TResult Function(_Divide value)? divide,
    TResult Function(_Multiply value)? multiply,
    TResult Function(_Number value)? number,
    TResult Function(_Substract value)? substract,
  }) {
    return divide?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Add value)? add,
    TResult Function(_Divide value)? divide,
    TResult Function(_Multiply value)? multiply,
    TResult Function(_Number value)? number,
    TResult Function(_Substract value)? substract,
    required TResult orElse(),
  }) {
    if (divide != null) {
      return divide(this);
    }
    return orElse();
  }
}

abstract class _Divide implements CalculatorItem {
  const factory _Divide() = _$_Divide;
}

/// @nodoc
abstract class _$$_MultiplyCopyWith<$Res> {
  factory _$$_MultiplyCopyWith(
          _$_Multiply value, $Res Function(_$_Multiply) then) =
      __$$_MultiplyCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_MultiplyCopyWithImpl<$Res> extends _$CalculatorItemCopyWithImpl<$Res>
    implements _$$_MultiplyCopyWith<$Res> {
  __$$_MultiplyCopyWithImpl(
      _$_Multiply _value, $Res Function(_$_Multiply) _then)
      : super(_value, (v) => _then(v as _$_Multiply));

  @override
  _$_Multiply get _value => super._value as _$_Multiply;
}

/// @nodoc

class _$_Multiply implements _Multiply {
  const _$_Multiply();

  @override
  String toString() {
    return 'CalculatorItem.multiply()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Multiply);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() add,
    required TResult Function() divide,
    required TResult Function() multiply,
    required TResult Function(String value) number,
    required TResult Function() substract,
  }) {
    return multiply();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? add,
    TResult Function()? divide,
    TResult Function()? multiply,
    TResult Function(String value)? number,
    TResult Function()? substract,
  }) {
    return multiply?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? add,
    TResult Function()? divide,
    TResult Function()? multiply,
    TResult Function(String value)? number,
    TResult Function()? substract,
    required TResult orElse(),
  }) {
    if (multiply != null) {
      return multiply();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Add value) add,
    required TResult Function(_Divide value) divide,
    required TResult Function(_Multiply value) multiply,
    required TResult Function(_Number value) number,
    required TResult Function(_Substract value) substract,
  }) {
    return multiply(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Add value)? add,
    TResult Function(_Divide value)? divide,
    TResult Function(_Multiply value)? multiply,
    TResult Function(_Number value)? number,
    TResult Function(_Substract value)? substract,
  }) {
    return multiply?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Add value)? add,
    TResult Function(_Divide value)? divide,
    TResult Function(_Multiply value)? multiply,
    TResult Function(_Number value)? number,
    TResult Function(_Substract value)? substract,
    required TResult orElse(),
  }) {
    if (multiply != null) {
      return multiply(this);
    }
    return orElse();
  }
}

abstract class _Multiply implements CalculatorItem {
  const factory _Multiply() = _$_Multiply;
}

/// @nodoc
abstract class _$$_NumberCopyWith<$Res> {
  factory _$$_NumberCopyWith(_$_Number value, $Res Function(_$_Number) then) =
      __$$_NumberCopyWithImpl<$Res>;
  $Res call({String value});
}

/// @nodoc
class __$$_NumberCopyWithImpl<$Res> extends _$CalculatorItemCopyWithImpl<$Res>
    implements _$$_NumberCopyWith<$Res> {
  __$$_NumberCopyWithImpl(_$_Number _value, $Res Function(_$_Number) _then)
      : super(_value, (v) => _then(v as _$_Number));

  @override
  _$_Number get _value => super._value as _$_Number;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_$_Number(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_Number implements _Number {
  const _$_Number(this.value);

  @override
  final String value;

  @override
  String toString() {
    return 'CalculatorItem.number(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Number &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  _$$_NumberCopyWith<_$_Number> get copyWith =>
      __$$_NumberCopyWithImpl<_$_Number>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() add,
    required TResult Function() divide,
    required TResult Function() multiply,
    required TResult Function(String value) number,
    required TResult Function() substract,
  }) {
    return number(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? add,
    TResult Function()? divide,
    TResult Function()? multiply,
    TResult Function(String value)? number,
    TResult Function()? substract,
  }) {
    return number?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? add,
    TResult Function()? divide,
    TResult Function()? multiply,
    TResult Function(String value)? number,
    TResult Function()? substract,
    required TResult orElse(),
  }) {
    if (number != null) {
      return number(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Add value) add,
    required TResult Function(_Divide value) divide,
    required TResult Function(_Multiply value) multiply,
    required TResult Function(_Number value) number,
    required TResult Function(_Substract value) substract,
  }) {
    return number(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Add value)? add,
    TResult Function(_Divide value)? divide,
    TResult Function(_Multiply value)? multiply,
    TResult Function(_Number value)? number,
    TResult Function(_Substract value)? substract,
  }) {
    return number?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Add value)? add,
    TResult Function(_Divide value)? divide,
    TResult Function(_Multiply value)? multiply,
    TResult Function(_Number value)? number,
    TResult Function(_Substract value)? substract,
    required TResult orElse(),
  }) {
    if (number != null) {
      return number(this);
    }
    return orElse();
  }
}

abstract class _Number implements CalculatorItem {
  const factory _Number(final String value) = _$_Number;

  String get value;
  @JsonKey(ignore: true)
  _$$_NumberCopyWith<_$_Number> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_SubstractCopyWith<$Res> {
  factory _$$_SubstractCopyWith(
          _$_Substract value, $Res Function(_$_Substract) then) =
      __$$_SubstractCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_SubstractCopyWithImpl<$Res>
    extends _$CalculatorItemCopyWithImpl<$Res>
    implements _$$_SubstractCopyWith<$Res> {
  __$$_SubstractCopyWithImpl(
      _$_Substract _value, $Res Function(_$_Substract) _then)
      : super(_value, (v) => _then(v as _$_Substract));

  @override
  _$_Substract get _value => super._value as _$_Substract;
}

/// @nodoc

class _$_Substract implements _Substract {
  const _$_Substract();

  @override
  String toString() {
    return 'CalculatorItem.substract()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Substract);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() add,
    required TResult Function() divide,
    required TResult Function() multiply,
    required TResult Function(String value) number,
    required TResult Function() substract,
  }) {
    return substract();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? add,
    TResult Function()? divide,
    TResult Function()? multiply,
    TResult Function(String value)? number,
    TResult Function()? substract,
  }) {
    return substract?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? add,
    TResult Function()? divide,
    TResult Function()? multiply,
    TResult Function(String value)? number,
    TResult Function()? substract,
    required TResult orElse(),
  }) {
    if (substract != null) {
      return substract();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Add value) add,
    required TResult Function(_Divide value) divide,
    required TResult Function(_Multiply value) multiply,
    required TResult Function(_Number value) number,
    required TResult Function(_Substract value) substract,
  }) {
    return substract(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Add value)? add,
    TResult Function(_Divide value)? divide,
    TResult Function(_Multiply value)? multiply,
    TResult Function(_Number value)? number,
    TResult Function(_Substract value)? substract,
  }) {
    return substract?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Add value)? add,
    TResult Function(_Divide value)? divide,
    TResult Function(_Multiply value)? multiply,
    TResult Function(_Number value)? number,
    TResult Function(_Substract value)? substract,
    required TResult orElse(),
  }) {
    if (substract != null) {
      return substract(this);
    }
    return orElse();
  }
}

abstract class _Substract implements CalculatorItem {
  const factory _Substract() = _$_Substract;
}
