// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'enter_amount_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$EnterAmountEventTearOff {
  const _$EnterAmountEventTearOff();

  _BackspacePress backspacePress() {
    return const _BackspacePress();
  }

  _ClearPress clearPress() {
    return const _ClearPress();
  }

  _DotPress dotPress() {
    return const _DotPress();
  }

  _EqualPress equalPress() {
    return const _EqualPress();
  }

  _NumberPress numberPress(int number) {
    return _NumberPress(
      number,
    );
  }

  _OperatorPress operatorPress(CalculatorItem calOperator) {
    return _OperatorPress(
      calOperator,
    );
  }

  _ThreeZeroPress threeZeroPress() {
    return const _ThreeZeroPress();
  }
}

/// @nodoc
const $EnterAmountEvent = _$EnterAmountEventTearOff();

/// @nodoc
mixin _$EnterAmountEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() backspacePress,
    required TResult Function() clearPress,
    required TResult Function() dotPress,
    required TResult Function() equalPress,
    required TResult Function(int number) numberPress,
    required TResult Function(CalculatorItem calOperator) operatorPress,
    required TResult Function() threeZeroPress,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? backspacePress,
    TResult Function()? clearPress,
    TResult Function()? dotPress,
    TResult Function()? equalPress,
    TResult Function(int number)? numberPress,
    TResult Function(CalculatorItem calOperator)? operatorPress,
    TResult Function()? threeZeroPress,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? backspacePress,
    TResult Function()? clearPress,
    TResult Function()? dotPress,
    TResult Function()? equalPress,
    TResult Function(int number)? numberPress,
    TResult Function(CalculatorItem calOperator)? operatorPress,
    TResult Function()? threeZeroPress,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_BackspacePress value) backspacePress,
    required TResult Function(_ClearPress value) clearPress,
    required TResult Function(_DotPress value) dotPress,
    required TResult Function(_EqualPress value) equalPress,
    required TResult Function(_NumberPress value) numberPress,
    required TResult Function(_OperatorPress value) operatorPress,
    required TResult Function(_ThreeZeroPress value) threeZeroPress,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_BackspacePress value)? backspacePress,
    TResult Function(_ClearPress value)? clearPress,
    TResult Function(_DotPress value)? dotPress,
    TResult Function(_EqualPress value)? equalPress,
    TResult Function(_NumberPress value)? numberPress,
    TResult Function(_OperatorPress value)? operatorPress,
    TResult Function(_ThreeZeroPress value)? threeZeroPress,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_BackspacePress value)? backspacePress,
    TResult Function(_ClearPress value)? clearPress,
    TResult Function(_DotPress value)? dotPress,
    TResult Function(_EqualPress value)? equalPress,
    TResult Function(_NumberPress value)? numberPress,
    TResult Function(_OperatorPress value)? operatorPress,
    TResult Function(_ThreeZeroPress value)? threeZeroPress,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EnterAmountEventCopyWith<$Res> {
  factory $EnterAmountEventCopyWith(
          EnterAmountEvent value, $Res Function(EnterAmountEvent) then) =
      _$EnterAmountEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$EnterAmountEventCopyWithImpl<$Res>
    implements $EnterAmountEventCopyWith<$Res> {
  _$EnterAmountEventCopyWithImpl(this._value, this._then);

  final EnterAmountEvent _value;
  // ignore: unused_field
  final $Res Function(EnterAmountEvent) _then;
}

/// @nodoc
abstract class _$BackspacePressCopyWith<$Res> {
  factory _$BackspacePressCopyWith(
          _BackspacePress value, $Res Function(_BackspacePress) then) =
      __$BackspacePressCopyWithImpl<$Res>;
}

/// @nodoc
class __$BackspacePressCopyWithImpl<$Res>
    extends _$EnterAmountEventCopyWithImpl<$Res>
    implements _$BackspacePressCopyWith<$Res> {
  __$BackspacePressCopyWithImpl(
      _BackspacePress _value, $Res Function(_BackspacePress) _then)
      : super(_value, (v) => _then(v as _BackspacePress));

  @override
  _BackspacePress get _value => super._value as _BackspacePress;
}

/// @nodoc

class _$_BackspacePress implements _BackspacePress {
  const _$_BackspacePress();

  @override
  String toString() {
    return 'EnterAmountEvent.backspacePress()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _BackspacePress);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() backspacePress,
    required TResult Function() clearPress,
    required TResult Function() dotPress,
    required TResult Function() equalPress,
    required TResult Function(int number) numberPress,
    required TResult Function(CalculatorItem calOperator) operatorPress,
    required TResult Function() threeZeroPress,
  }) {
    return backspacePress();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? backspacePress,
    TResult Function()? clearPress,
    TResult Function()? dotPress,
    TResult Function()? equalPress,
    TResult Function(int number)? numberPress,
    TResult Function(CalculatorItem calOperator)? operatorPress,
    TResult Function()? threeZeroPress,
  }) {
    return backspacePress?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? backspacePress,
    TResult Function()? clearPress,
    TResult Function()? dotPress,
    TResult Function()? equalPress,
    TResult Function(int number)? numberPress,
    TResult Function(CalculatorItem calOperator)? operatorPress,
    TResult Function()? threeZeroPress,
    required TResult orElse(),
  }) {
    if (backspacePress != null) {
      return backspacePress();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_BackspacePress value) backspacePress,
    required TResult Function(_ClearPress value) clearPress,
    required TResult Function(_DotPress value) dotPress,
    required TResult Function(_EqualPress value) equalPress,
    required TResult Function(_NumberPress value) numberPress,
    required TResult Function(_OperatorPress value) operatorPress,
    required TResult Function(_ThreeZeroPress value) threeZeroPress,
  }) {
    return backspacePress(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_BackspacePress value)? backspacePress,
    TResult Function(_ClearPress value)? clearPress,
    TResult Function(_DotPress value)? dotPress,
    TResult Function(_EqualPress value)? equalPress,
    TResult Function(_NumberPress value)? numberPress,
    TResult Function(_OperatorPress value)? operatorPress,
    TResult Function(_ThreeZeroPress value)? threeZeroPress,
  }) {
    return backspacePress?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_BackspacePress value)? backspacePress,
    TResult Function(_ClearPress value)? clearPress,
    TResult Function(_DotPress value)? dotPress,
    TResult Function(_EqualPress value)? equalPress,
    TResult Function(_NumberPress value)? numberPress,
    TResult Function(_OperatorPress value)? operatorPress,
    TResult Function(_ThreeZeroPress value)? threeZeroPress,
    required TResult orElse(),
  }) {
    if (backspacePress != null) {
      return backspacePress(this);
    }
    return orElse();
  }
}

abstract class _BackspacePress implements EnterAmountEvent {
  const factory _BackspacePress() = _$_BackspacePress;
}

/// @nodoc
abstract class _$ClearPressCopyWith<$Res> {
  factory _$ClearPressCopyWith(
          _ClearPress value, $Res Function(_ClearPress) then) =
      __$ClearPressCopyWithImpl<$Res>;
}

/// @nodoc
class __$ClearPressCopyWithImpl<$Res>
    extends _$EnterAmountEventCopyWithImpl<$Res>
    implements _$ClearPressCopyWith<$Res> {
  __$ClearPressCopyWithImpl(
      _ClearPress _value, $Res Function(_ClearPress) _then)
      : super(_value, (v) => _then(v as _ClearPress));

  @override
  _ClearPress get _value => super._value as _ClearPress;
}

/// @nodoc

class _$_ClearPress implements _ClearPress {
  const _$_ClearPress();

  @override
  String toString() {
    return 'EnterAmountEvent.clearPress()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _ClearPress);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() backspacePress,
    required TResult Function() clearPress,
    required TResult Function() dotPress,
    required TResult Function() equalPress,
    required TResult Function(int number) numberPress,
    required TResult Function(CalculatorItem calOperator) operatorPress,
    required TResult Function() threeZeroPress,
  }) {
    return clearPress();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? backspacePress,
    TResult Function()? clearPress,
    TResult Function()? dotPress,
    TResult Function()? equalPress,
    TResult Function(int number)? numberPress,
    TResult Function(CalculatorItem calOperator)? operatorPress,
    TResult Function()? threeZeroPress,
  }) {
    return clearPress?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? backspacePress,
    TResult Function()? clearPress,
    TResult Function()? dotPress,
    TResult Function()? equalPress,
    TResult Function(int number)? numberPress,
    TResult Function(CalculatorItem calOperator)? operatorPress,
    TResult Function()? threeZeroPress,
    required TResult orElse(),
  }) {
    if (clearPress != null) {
      return clearPress();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_BackspacePress value) backspacePress,
    required TResult Function(_ClearPress value) clearPress,
    required TResult Function(_DotPress value) dotPress,
    required TResult Function(_EqualPress value) equalPress,
    required TResult Function(_NumberPress value) numberPress,
    required TResult Function(_OperatorPress value) operatorPress,
    required TResult Function(_ThreeZeroPress value) threeZeroPress,
  }) {
    return clearPress(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_BackspacePress value)? backspacePress,
    TResult Function(_ClearPress value)? clearPress,
    TResult Function(_DotPress value)? dotPress,
    TResult Function(_EqualPress value)? equalPress,
    TResult Function(_NumberPress value)? numberPress,
    TResult Function(_OperatorPress value)? operatorPress,
    TResult Function(_ThreeZeroPress value)? threeZeroPress,
  }) {
    return clearPress?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_BackspacePress value)? backspacePress,
    TResult Function(_ClearPress value)? clearPress,
    TResult Function(_DotPress value)? dotPress,
    TResult Function(_EqualPress value)? equalPress,
    TResult Function(_NumberPress value)? numberPress,
    TResult Function(_OperatorPress value)? operatorPress,
    TResult Function(_ThreeZeroPress value)? threeZeroPress,
    required TResult orElse(),
  }) {
    if (clearPress != null) {
      return clearPress(this);
    }
    return orElse();
  }
}

abstract class _ClearPress implements EnterAmountEvent {
  const factory _ClearPress() = _$_ClearPress;
}

/// @nodoc
abstract class _$DotPressCopyWith<$Res> {
  factory _$DotPressCopyWith(_DotPress value, $Res Function(_DotPress) then) =
      __$DotPressCopyWithImpl<$Res>;
}

/// @nodoc
class __$DotPressCopyWithImpl<$Res> extends _$EnterAmountEventCopyWithImpl<$Res>
    implements _$DotPressCopyWith<$Res> {
  __$DotPressCopyWithImpl(_DotPress _value, $Res Function(_DotPress) _then)
      : super(_value, (v) => _then(v as _DotPress));

  @override
  _DotPress get _value => super._value as _DotPress;
}

/// @nodoc

class _$_DotPress implements _DotPress {
  const _$_DotPress();

  @override
  String toString() {
    return 'EnterAmountEvent.dotPress()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _DotPress);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() backspacePress,
    required TResult Function() clearPress,
    required TResult Function() dotPress,
    required TResult Function() equalPress,
    required TResult Function(int number) numberPress,
    required TResult Function(CalculatorItem calOperator) operatorPress,
    required TResult Function() threeZeroPress,
  }) {
    return dotPress();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? backspacePress,
    TResult Function()? clearPress,
    TResult Function()? dotPress,
    TResult Function()? equalPress,
    TResult Function(int number)? numberPress,
    TResult Function(CalculatorItem calOperator)? operatorPress,
    TResult Function()? threeZeroPress,
  }) {
    return dotPress?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? backspacePress,
    TResult Function()? clearPress,
    TResult Function()? dotPress,
    TResult Function()? equalPress,
    TResult Function(int number)? numberPress,
    TResult Function(CalculatorItem calOperator)? operatorPress,
    TResult Function()? threeZeroPress,
    required TResult orElse(),
  }) {
    if (dotPress != null) {
      return dotPress();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_BackspacePress value) backspacePress,
    required TResult Function(_ClearPress value) clearPress,
    required TResult Function(_DotPress value) dotPress,
    required TResult Function(_EqualPress value) equalPress,
    required TResult Function(_NumberPress value) numberPress,
    required TResult Function(_OperatorPress value) operatorPress,
    required TResult Function(_ThreeZeroPress value) threeZeroPress,
  }) {
    return dotPress(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_BackspacePress value)? backspacePress,
    TResult Function(_ClearPress value)? clearPress,
    TResult Function(_DotPress value)? dotPress,
    TResult Function(_EqualPress value)? equalPress,
    TResult Function(_NumberPress value)? numberPress,
    TResult Function(_OperatorPress value)? operatorPress,
    TResult Function(_ThreeZeroPress value)? threeZeroPress,
  }) {
    return dotPress?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_BackspacePress value)? backspacePress,
    TResult Function(_ClearPress value)? clearPress,
    TResult Function(_DotPress value)? dotPress,
    TResult Function(_EqualPress value)? equalPress,
    TResult Function(_NumberPress value)? numberPress,
    TResult Function(_OperatorPress value)? operatorPress,
    TResult Function(_ThreeZeroPress value)? threeZeroPress,
    required TResult orElse(),
  }) {
    if (dotPress != null) {
      return dotPress(this);
    }
    return orElse();
  }
}

abstract class _DotPress implements EnterAmountEvent {
  const factory _DotPress() = _$_DotPress;
}

/// @nodoc
abstract class _$EqualPressCopyWith<$Res> {
  factory _$EqualPressCopyWith(
          _EqualPress value, $Res Function(_EqualPress) then) =
      __$EqualPressCopyWithImpl<$Res>;
}

/// @nodoc
class __$EqualPressCopyWithImpl<$Res>
    extends _$EnterAmountEventCopyWithImpl<$Res>
    implements _$EqualPressCopyWith<$Res> {
  __$EqualPressCopyWithImpl(
      _EqualPress _value, $Res Function(_EqualPress) _then)
      : super(_value, (v) => _then(v as _EqualPress));

  @override
  _EqualPress get _value => super._value as _EqualPress;
}

/// @nodoc

class _$_EqualPress implements _EqualPress {
  const _$_EqualPress();

  @override
  String toString() {
    return 'EnterAmountEvent.equalPress()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _EqualPress);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() backspacePress,
    required TResult Function() clearPress,
    required TResult Function() dotPress,
    required TResult Function() equalPress,
    required TResult Function(int number) numberPress,
    required TResult Function(CalculatorItem calOperator) operatorPress,
    required TResult Function() threeZeroPress,
  }) {
    return equalPress();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? backspacePress,
    TResult Function()? clearPress,
    TResult Function()? dotPress,
    TResult Function()? equalPress,
    TResult Function(int number)? numberPress,
    TResult Function(CalculatorItem calOperator)? operatorPress,
    TResult Function()? threeZeroPress,
  }) {
    return equalPress?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? backspacePress,
    TResult Function()? clearPress,
    TResult Function()? dotPress,
    TResult Function()? equalPress,
    TResult Function(int number)? numberPress,
    TResult Function(CalculatorItem calOperator)? operatorPress,
    TResult Function()? threeZeroPress,
    required TResult orElse(),
  }) {
    if (equalPress != null) {
      return equalPress();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_BackspacePress value) backspacePress,
    required TResult Function(_ClearPress value) clearPress,
    required TResult Function(_DotPress value) dotPress,
    required TResult Function(_EqualPress value) equalPress,
    required TResult Function(_NumberPress value) numberPress,
    required TResult Function(_OperatorPress value) operatorPress,
    required TResult Function(_ThreeZeroPress value) threeZeroPress,
  }) {
    return equalPress(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_BackspacePress value)? backspacePress,
    TResult Function(_ClearPress value)? clearPress,
    TResult Function(_DotPress value)? dotPress,
    TResult Function(_EqualPress value)? equalPress,
    TResult Function(_NumberPress value)? numberPress,
    TResult Function(_OperatorPress value)? operatorPress,
    TResult Function(_ThreeZeroPress value)? threeZeroPress,
  }) {
    return equalPress?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_BackspacePress value)? backspacePress,
    TResult Function(_ClearPress value)? clearPress,
    TResult Function(_DotPress value)? dotPress,
    TResult Function(_EqualPress value)? equalPress,
    TResult Function(_NumberPress value)? numberPress,
    TResult Function(_OperatorPress value)? operatorPress,
    TResult Function(_ThreeZeroPress value)? threeZeroPress,
    required TResult orElse(),
  }) {
    if (equalPress != null) {
      return equalPress(this);
    }
    return orElse();
  }
}

abstract class _EqualPress implements EnterAmountEvent {
  const factory _EqualPress() = _$_EqualPress;
}

/// @nodoc
abstract class _$NumberPressCopyWith<$Res> {
  factory _$NumberPressCopyWith(
          _NumberPress value, $Res Function(_NumberPress) then) =
      __$NumberPressCopyWithImpl<$Res>;
  $Res call({int number});
}

/// @nodoc
class __$NumberPressCopyWithImpl<$Res>
    extends _$EnterAmountEventCopyWithImpl<$Res>
    implements _$NumberPressCopyWith<$Res> {
  __$NumberPressCopyWithImpl(
      _NumberPress _value, $Res Function(_NumberPress) _then)
      : super(_value, (v) => _then(v as _NumberPress));

  @override
  _NumberPress get _value => super._value as _NumberPress;

  @override
  $Res call({
    Object? number = freezed,
  }) {
    return _then(_NumberPress(
      number == freezed
          ? _value.number
          : number // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_NumberPress implements _NumberPress {
  const _$_NumberPress(this.number);

  @override
  final int number;

  @override
  String toString() {
    return 'EnterAmountEvent.numberPress(number: $number)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _NumberPress &&
            const DeepCollectionEquality().equals(other.number, number));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(number));

  @JsonKey(ignore: true)
  @override
  _$NumberPressCopyWith<_NumberPress> get copyWith =>
      __$NumberPressCopyWithImpl<_NumberPress>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() backspacePress,
    required TResult Function() clearPress,
    required TResult Function() dotPress,
    required TResult Function() equalPress,
    required TResult Function(int number) numberPress,
    required TResult Function(CalculatorItem calOperator) operatorPress,
    required TResult Function() threeZeroPress,
  }) {
    return numberPress(number);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? backspacePress,
    TResult Function()? clearPress,
    TResult Function()? dotPress,
    TResult Function()? equalPress,
    TResult Function(int number)? numberPress,
    TResult Function(CalculatorItem calOperator)? operatorPress,
    TResult Function()? threeZeroPress,
  }) {
    return numberPress?.call(number);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? backspacePress,
    TResult Function()? clearPress,
    TResult Function()? dotPress,
    TResult Function()? equalPress,
    TResult Function(int number)? numberPress,
    TResult Function(CalculatorItem calOperator)? operatorPress,
    TResult Function()? threeZeroPress,
    required TResult orElse(),
  }) {
    if (numberPress != null) {
      return numberPress(number);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_BackspacePress value) backspacePress,
    required TResult Function(_ClearPress value) clearPress,
    required TResult Function(_DotPress value) dotPress,
    required TResult Function(_EqualPress value) equalPress,
    required TResult Function(_NumberPress value) numberPress,
    required TResult Function(_OperatorPress value) operatorPress,
    required TResult Function(_ThreeZeroPress value) threeZeroPress,
  }) {
    return numberPress(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_BackspacePress value)? backspacePress,
    TResult Function(_ClearPress value)? clearPress,
    TResult Function(_DotPress value)? dotPress,
    TResult Function(_EqualPress value)? equalPress,
    TResult Function(_NumberPress value)? numberPress,
    TResult Function(_OperatorPress value)? operatorPress,
    TResult Function(_ThreeZeroPress value)? threeZeroPress,
  }) {
    return numberPress?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_BackspacePress value)? backspacePress,
    TResult Function(_ClearPress value)? clearPress,
    TResult Function(_DotPress value)? dotPress,
    TResult Function(_EqualPress value)? equalPress,
    TResult Function(_NumberPress value)? numberPress,
    TResult Function(_OperatorPress value)? operatorPress,
    TResult Function(_ThreeZeroPress value)? threeZeroPress,
    required TResult orElse(),
  }) {
    if (numberPress != null) {
      return numberPress(this);
    }
    return orElse();
  }
}

abstract class _NumberPress implements EnterAmountEvent {
  const factory _NumberPress(int number) = _$_NumberPress;

  int get number;
  @JsonKey(ignore: true)
  _$NumberPressCopyWith<_NumberPress> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$OperatorPressCopyWith<$Res> {
  factory _$OperatorPressCopyWith(
          _OperatorPress value, $Res Function(_OperatorPress) then) =
      __$OperatorPressCopyWithImpl<$Res>;
  $Res call({CalculatorItem calOperator});

  $CalculatorItemCopyWith<$Res> get calOperator;
}

/// @nodoc
class __$OperatorPressCopyWithImpl<$Res>
    extends _$EnterAmountEventCopyWithImpl<$Res>
    implements _$OperatorPressCopyWith<$Res> {
  __$OperatorPressCopyWithImpl(
      _OperatorPress _value, $Res Function(_OperatorPress) _then)
      : super(_value, (v) => _then(v as _OperatorPress));

  @override
  _OperatorPress get _value => super._value as _OperatorPress;

  @override
  $Res call({
    Object? calOperator = freezed,
  }) {
    return _then(_OperatorPress(
      calOperator == freezed
          ? _value.calOperator
          : calOperator // ignore: cast_nullable_to_non_nullable
              as CalculatorItem,
    ));
  }

  @override
  $CalculatorItemCopyWith<$Res> get calOperator {
    return $CalculatorItemCopyWith<$Res>(_value.calOperator, (value) {
      return _then(_value.copyWith(calOperator: value));
    });
  }
}

/// @nodoc

class _$_OperatorPress implements _OperatorPress {
  const _$_OperatorPress(this.calOperator);

  @override
  final CalculatorItem calOperator;

  @override
  String toString() {
    return 'EnterAmountEvent.operatorPress(calOperator: $calOperator)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _OperatorPress &&
            const DeepCollectionEquality()
                .equals(other.calOperator, calOperator));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(calOperator));

  @JsonKey(ignore: true)
  @override
  _$OperatorPressCopyWith<_OperatorPress> get copyWith =>
      __$OperatorPressCopyWithImpl<_OperatorPress>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() backspacePress,
    required TResult Function() clearPress,
    required TResult Function() dotPress,
    required TResult Function() equalPress,
    required TResult Function(int number) numberPress,
    required TResult Function(CalculatorItem calOperator) operatorPress,
    required TResult Function() threeZeroPress,
  }) {
    return operatorPress(calOperator);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? backspacePress,
    TResult Function()? clearPress,
    TResult Function()? dotPress,
    TResult Function()? equalPress,
    TResult Function(int number)? numberPress,
    TResult Function(CalculatorItem calOperator)? operatorPress,
    TResult Function()? threeZeroPress,
  }) {
    return operatorPress?.call(calOperator);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? backspacePress,
    TResult Function()? clearPress,
    TResult Function()? dotPress,
    TResult Function()? equalPress,
    TResult Function(int number)? numberPress,
    TResult Function(CalculatorItem calOperator)? operatorPress,
    TResult Function()? threeZeroPress,
    required TResult orElse(),
  }) {
    if (operatorPress != null) {
      return operatorPress(calOperator);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_BackspacePress value) backspacePress,
    required TResult Function(_ClearPress value) clearPress,
    required TResult Function(_DotPress value) dotPress,
    required TResult Function(_EqualPress value) equalPress,
    required TResult Function(_NumberPress value) numberPress,
    required TResult Function(_OperatorPress value) operatorPress,
    required TResult Function(_ThreeZeroPress value) threeZeroPress,
  }) {
    return operatorPress(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_BackspacePress value)? backspacePress,
    TResult Function(_ClearPress value)? clearPress,
    TResult Function(_DotPress value)? dotPress,
    TResult Function(_EqualPress value)? equalPress,
    TResult Function(_NumberPress value)? numberPress,
    TResult Function(_OperatorPress value)? operatorPress,
    TResult Function(_ThreeZeroPress value)? threeZeroPress,
  }) {
    return operatorPress?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_BackspacePress value)? backspacePress,
    TResult Function(_ClearPress value)? clearPress,
    TResult Function(_DotPress value)? dotPress,
    TResult Function(_EqualPress value)? equalPress,
    TResult Function(_NumberPress value)? numberPress,
    TResult Function(_OperatorPress value)? operatorPress,
    TResult Function(_ThreeZeroPress value)? threeZeroPress,
    required TResult orElse(),
  }) {
    if (operatorPress != null) {
      return operatorPress(this);
    }
    return orElse();
  }
}

abstract class _OperatorPress implements EnterAmountEvent {
  const factory _OperatorPress(CalculatorItem calOperator) = _$_OperatorPress;

  CalculatorItem get calOperator;
  @JsonKey(ignore: true)
  _$OperatorPressCopyWith<_OperatorPress> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$ThreeZeroPressCopyWith<$Res> {
  factory _$ThreeZeroPressCopyWith(
          _ThreeZeroPress value, $Res Function(_ThreeZeroPress) then) =
      __$ThreeZeroPressCopyWithImpl<$Res>;
}

/// @nodoc
class __$ThreeZeroPressCopyWithImpl<$Res>
    extends _$EnterAmountEventCopyWithImpl<$Res>
    implements _$ThreeZeroPressCopyWith<$Res> {
  __$ThreeZeroPressCopyWithImpl(
      _ThreeZeroPress _value, $Res Function(_ThreeZeroPress) _then)
      : super(_value, (v) => _then(v as _ThreeZeroPress));

  @override
  _ThreeZeroPress get _value => super._value as _ThreeZeroPress;
}

/// @nodoc

class _$_ThreeZeroPress implements _ThreeZeroPress {
  const _$_ThreeZeroPress();

  @override
  String toString() {
    return 'EnterAmountEvent.threeZeroPress()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _ThreeZeroPress);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() backspacePress,
    required TResult Function() clearPress,
    required TResult Function() dotPress,
    required TResult Function() equalPress,
    required TResult Function(int number) numberPress,
    required TResult Function(CalculatorItem calOperator) operatorPress,
    required TResult Function() threeZeroPress,
  }) {
    return threeZeroPress();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? backspacePress,
    TResult Function()? clearPress,
    TResult Function()? dotPress,
    TResult Function()? equalPress,
    TResult Function(int number)? numberPress,
    TResult Function(CalculatorItem calOperator)? operatorPress,
    TResult Function()? threeZeroPress,
  }) {
    return threeZeroPress?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? backspacePress,
    TResult Function()? clearPress,
    TResult Function()? dotPress,
    TResult Function()? equalPress,
    TResult Function(int number)? numberPress,
    TResult Function(CalculatorItem calOperator)? operatorPress,
    TResult Function()? threeZeroPress,
    required TResult orElse(),
  }) {
    if (threeZeroPress != null) {
      return threeZeroPress();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_BackspacePress value) backspacePress,
    required TResult Function(_ClearPress value) clearPress,
    required TResult Function(_DotPress value) dotPress,
    required TResult Function(_EqualPress value) equalPress,
    required TResult Function(_NumberPress value) numberPress,
    required TResult Function(_OperatorPress value) operatorPress,
    required TResult Function(_ThreeZeroPress value) threeZeroPress,
  }) {
    return threeZeroPress(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_BackspacePress value)? backspacePress,
    TResult Function(_ClearPress value)? clearPress,
    TResult Function(_DotPress value)? dotPress,
    TResult Function(_EqualPress value)? equalPress,
    TResult Function(_NumberPress value)? numberPress,
    TResult Function(_OperatorPress value)? operatorPress,
    TResult Function(_ThreeZeroPress value)? threeZeroPress,
  }) {
    return threeZeroPress?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_BackspacePress value)? backspacePress,
    TResult Function(_ClearPress value)? clearPress,
    TResult Function(_DotPress value)? dotPress,
    TResult Function(_EqualPress value)? equalPress,
    TResult Function(_NumberPress value)? numberPress,
    TResult Function(_OperatorPress value)? operatorPress,
    TResult Function(_ThreeZeroPress value)? threeZeroPress,
    required TResult orElse(),
  }) {
    if (threeZeroPress != null) {
      return threeZeroPress(this);
    }
    return orElse();
  }
}

abstract class _ThreeZeroPress implements EnterAmountEvent {
  const factory _ThreeZeroPress() = _$_ThreeZeroPress;
}

/// @nodoc
class _$EnterAmountStateTearOff {
  const _$EnterAmountStateTearOff();

  _EnterAmountState call(
      {required IList<CalculatorItem> calItems,
      required bool incorrecFormat,
      required Option<String> valueErrorMgs}) {
    return _EnterAmountState(
      calItems: calItems,
      incorrecFormat: incorrecFormat,
      valueErrorMgs: valueErrorMgs,
    );
  }
}

/// @nodoc
const $EnterAmountState = _$EnterAmountStateTearOff();

/// @nodoc
mixin _$EnterAmountState {
  /// Calculate items for perfom calculate. eg 2+20-5*5
  /// When click = this will use to calculate value
  IList<CalculatorItem> get calItems => throw _privateConstructorUsedError;

  /// If value to calculate is incorrect
  bool get incorrecFormat => throw _privateConstructorUsedError;

  /// Value error message
  Option<String> get valueErrorMgs => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $EnterAmountStateCopyWith<EnterAmountState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EnterAmountStateCopyWith<$Res> {
  factory $EnterAmountStateCopyWith(
          EnterAmountState value, $Res Function(EnterAmountState) then) =
      _$EnterAmountStateCopyWithImpl<$Res>;
  $Res call(
      {IList<CalculatorItem> calItems,
      bool incorrecFormat,
      Option<String> valueErrorMgs});
}

/// @nodoc
class _$EnterAmountStateCopyWithImpl<$Res>
    implements $EnterAmountStateCopyWith<$Res> {
  _$EnterAmountStateCopyWithImpl(this._value, this._then);

  final EnterAmountState _value;
  // ignore: unused_field
  final $Res Function(EnterAmountState) _then;

  @override
  $Res call({
    Object? calItems = freezed,
    Object? incorrecFormat = freezed,
    Object? valueErrorMgs = freezed,
  }) {
    return _then(_value.copyWith(
      calItems: calItems == freezed
          ? _value.calItems
          : calItems // ignore: cast_nullable_to_non_nullable
              as IList<CalculatorItem>,
      incorrecFormat: incorrecFormat == freezed
          ? _value.incorrecFormat
          : incorrecFormat // ignore: cast_nullable_to_non_nullable
              as bool,
      valueErrorMgs: valueErrorMgs == freezed
          ? _value.valueErrorMgs
          : valueErrorMgs // ignore: cast_nullable_to_non_nullable
              as Option<String>,
    ));
  }
}

/// @nodoc
abstract class _$EnterAmountStateCopyWith<$Res>
    implements $EnterAmountStateCopyWith<$Res> {
  factory _$EnterAmountStateCopyWith(
          _EnterAmountState value, $Res Function(_EnterAmountState) then) =
      __$EnterAmountStateCopyWithImpl<$Res>;
  @override
  $Res call(
      {IList<CalculatorItem> calItems,
      bool incorrecFormat,
      Option<String> valueErrorMgs});
}

/// @nodoc
class __$EnterAmountStateCopyWithImpl<$Res>
    extends _$EnterAmountStateCopyWithImpl<$Res>
    implements _$EnterAmountStateCopyWith<$Res> {
  __$EnterAmountStateCopyWithImpl(
      _EnterAmountState _value, $Res Function(_EnterAmountState) _then)
      : super(_value, (v) => _then(v as _EnterAmountState));

  @override
  _EnterAmountState get _value => super._value as _EnterAmountState;

  @override
  $Res call({
    Object? calItems = freezed,
    Object? incorrecFormat = freezed,
    Object? valueErrorMgs = freezed,
  }) {
    return _then(_EnterAmountState(
      calItems: calItems == freezed
          ? _value.calItems
          : calItems // ignore: cast_nullable_to_non_nullable
              as IList<CalculatorItem>,
      incorrecFormat: incorrecFormat == freezed
          ? _value.incorrecFormat
          : incorrecFormat // ignore: cast_nullable_to_non_nullable
              as bool,
      valueErrorMgs: valueErrorMgs == freezed
          ? _value.valueErrorMgs
          : valueErrorMgs // ignore: cast_nullable_to_non_nullable
              as Option<String>,
    ));
  }
}

/// @nodoc

class _$_EnterAmountState extends _EnterAmountState {
  _$_EnterAmountState(
      {required this.calItems,
      required this.incorrecFormat,
      required this.valueErrorMgs})
      : super._();

  @override

  /// Calculate items for perfom calculate. eg 2+20-5*5
  /// When click = this will use to calculate value
  final IList<CalculatorItem> calItems;
  @override

  /// If value to calculate is incorrect
  final bool incorrecFormat;
  @override

  /// Value error message
  final Option<String> valueErrorMgs;

  @override
  String toString() {
    return 'EnterAmountState(calItems: $calItems, incorrecFormat: $incorrecFormat, valueErrorMgs: $valueErrorMgs)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _EnterAmountState &&
            const DeepCollectionEquality().equals(other.calItems, calItems) &&
            const DeepCollectionEquality()
                .equals(other.incorrecFormat, incorrecFormat) &&
            const DeepCollectionEquality()
                .equals(other.valueErrorMgs, valueErrorMgs));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(calItems),
      const DeepCollectionEquality().hash(incorrecFormat),
      const DeepCollectionEquality().hash(valueErrorMgs));

  @JsonKey(ignore: true)
  @override
  _$EnterAmountStateCopyWith<_EnterAmountState> get copyWith =>
      __$EnterAmountStateCopyWithImpl<_EnterAmountState>(this, _$identity);
}

abstract class _EnterAmountState extends EnterAmountState {
  factory _EnterAmountState(
      {required IList<CalculatorItem> calItems,
      required bool incorrecFormat,
      required Option<String> valueErrorMgs}) = _$_EnterAmountState;
  _EnterAmountState._() : super._();

  @override

  /// Calculate items for perfom calculate. eg 2+20-5*5
  /// When click = this will use to calculate value
  IList<CalculatorItem> get calItems;
  @override

  /// If value to calculate is incorrect
  bool get incorrecFormat;
  @override

  /// Value error message
  Option<String> get valueErrorMgs;
  @override
  @JsonKey(ignore: true)
  _$EnterAmountStateCopyWith<_EnterAmountState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$CalculatorItemTearOff {
  const _$CalculatorItemTearOff();

  _Add add() {
    return const _Add();
  }

  _Divide divide() {
    return const _Divide();
  }

  _Multiply multiply() {
    return const _Multiply();
  }

  _Number number(String value) {
    return _Number(
      value,
    );
  }

  _Substract substract() {
    return const _Substract();
  }
}

/// @nodoc
const $CalculatorItem = _$CalculatorItemTearOff();

/// @nodoc
mixin _$CalculatorItem {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() add,
    required TResult Function() divide,
    required TResult Function() multiply,
    required TResult Function(String value) number,
    required TResult Function() substract,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? add,
    TResult Function()? divide,
    TResult Function()? multiply,
    TResult Function(String value)? number,
    TResult Function()? substract,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? add,
    TResult Function()? divide,
    TResult Function()? multiply,
    TResult Function(String value)? number,
    TResult Function()? substract,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Add value) add,
    required TResult Function(_Divide value) divide,
    required TResult Function(_Multiply value) multiply,
    required TResult Function(_Number value) number,
    required TResult Function(_Substract value) substract,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Add value)? add,
    TResult Function(_Divide value)? divide,
    TResult Function(_Multiply value)? multiply,
    TResult Function(_Number value)? number,
    TResult Function(_Substract value)? substract,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Add value)? add,
    TResult Function(_Divide value)? divide,
    TResult Function(_Multiply value)? multiply,
    TResult Function(_Number value)? number,
    TResult Function(_Substract value)? substract,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CalculatorItemCopyWith<$Res> {
  factory $CalculatorItemCopyWith(
          CalculatorItem value, $Res Function(CalculatorItem) then) =
      _$CalculatorItemCopyWithImpl<$Res>;
}

/// @nodoc
class _$CalculatorItemCopyWithImpl<$Res>
    implements $CalculatorItemCopyWith<$Res> {
  _$CalculatorItemCopyWithImpl(this._value, this._then);

  final CalculatorItem _value;
  // ignore: unused_field
  final $Res Function(CalculatorItem) _then;
}

/// @nodoc
abstract class _$AddCopyWith<$Res> {
  factory _$AddCopyWith(_Add value, $Res Function(_Add) then) =
      __$AddCopyWithImpl<$Res>;
}

/// @nodoc
class __$AddCopyWithImpl<$Res> extends _$CalculatorItemCopyWithImpl<$Res>
    implements _$AddCopyWith<$Res> {
  __$AddCopyWithImpl(_Add _value, $Res Function(_Add) _then)
      : super(_value, (v) => _then(v as _Add));

  @override
  _Add get _value => super._value as _Add;
}

/// @nodoc

class _$_Add implements _Add {
  const _$_Add();

  @override
  String toString() {
    return 'CalculatorItem.add()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Add);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() add,
    required TResult Function() divide,
    required TResult Function() multiply,
    required TResult Function(String value) number,
    required TResult Function() substract,
  }) {
    return add();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? add,
    TResult Function()? divide,
    TResult Function()? multiply,
    TResult Function(String value)? number,
    TResult Function()? substract,
  }) {
    return add?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? add,
    TResult Function()? divide,
    TResult Function()? multiply,
    TResult Function(String value)? number,
    TResult Function()? substract,
    required TResult orElse(),
  }) {
    if (add != null) {
      return add();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Add value) add,
    required TResult Function(_Divide value) divide,
    required TResult Function(_Multiply value) multiply,
    required TResult Function(_Number value) number,
    required TResult Function(_Substract value) substract,
  }) {
    return add(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Add value)? add,
    TResult Function(_Divide value)? divide,
    TResult Function(_Multiply value)? multiply,
    TResult Function(_Number value)? number,
    TResult Function(_Substract value)? substract,
  }) {
    return add?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Add value)? add,
    TResult Function(_Divide value)? divide,
    TResult Function(_Multiply value)? multiply,
    TResult Function(_Number value)? number,
    TResult Function(_Substract value)? substract,
    required TResult orElse(),
  }) {
    if (add != null) {
      return add(this);
    }
    return orElse();
  }
}

abstract class _Add implements CalculatorItem {
  const factory _Add() = _$_Add;
}

/// @nodoc
abstract class _$DivideCopyWith<$Res> {
  factory _$DivideCopyWith(_Divide value, $Res Function(_Divide) then) =
      __$DivideCopyWithImpl<$Res>;
}

/// @nodoc
class __$DivideCopyWithImpl<$Res> extends _$CalculatorItemCopyWithImpl<$Res>
    implements _$DivideCopyWith<$Res> {
  __$DivideCopyWithImpl(_Divide _value, $Res Function(_Divide) _then)
      : super(_value, (v) => _then(v as _Divide));

  @override
  _Divide get _value => super._value as _Divide;
}

/// @nodoc

class _$_Divide implements _Divide {
  const _$_Divide();

  @override
  String toString() {
    return 'CalculatorItem.divide()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Divide);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() add,
    required TResult Function() divide,
    required TResult Function() multiply,
    required TResult Function(String value) number,
    required TResult Function() substract,
  }) {
    return divide();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? add,
    TResult Function()? divide,
    TResult Function()? multiply,
    TResult Function(String value)? number,
    TResult Function()? substract,
  }) {
    return divide?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? add,
    TResult Function()? divide,
    TResult Function()? multiply,
    TResult Function(String value)? number,
    TResult Function()? substract,
    required TResult orElse(),
  }) {
    if (divide != null) {
      return divide();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Add value) add,
    required TResult Function(_Divide value) divide,
    required TResult Function(_Multiply value) multiply,
    required TResult Function(_Number value) number,
    required TResult Function(_Substract value) substract,
  }) {
    return divide(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Add value)? add,
    TResult Function(_Divide value)? divide,
    TResult Function(_Multiply value)? multiply,
    TResult Function(_Number value)? number,
    TResult Function(_Substract value)? substract,
  }) {
    return divide?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Add value)? add,
    TResult Function(_Divide value)? divide,
    TResult Function(_Multiply value)? multiply,
    TResult Function(_Number value)? number,
    TResult Function(_Substract value)? substract,
    required TResult orElse(),
  }) {
    if (divide != null) {
      return divide(this);
    }
    return orElse();
  }
}

abstract class _Divide implements CalculatorItem {
  const factory _Divide() = _$_Divide;
}

/// @nodoc
abstract class _$MultiplyCopyWith<$Res> {
  factory _$MultiplyCopyWith(_Multiply value, $Res Function(_Multiply) then) =
      __$MultiplyCopyWithImpl<$Res>;
}

/// @nodoc
class __$MultiplyCopyWithImpl<$Res> extends _$CalculatorItemCopyWithImpl<$Res>
    implements _$MultiplyCopyWith<$Res> {
  __$MultiplyCopyWithImpl(_Multiply _value, $Res Function(_Multiply) _then)
      : super(_value, (v) => _then(v as _Multiply));

  @override
  _Multiply get _value => super._value as _Multiply;
}

/// @nodoc

class _$_Multiply implements _Multiply {
  const _$_Multiply();

  @override
  String toString() {
    return 'CalculatorItem.multiply()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Multiply);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() add,
    required TResult Function() divide,
    required TResult Function() multiply,
    required TResult Function(String value) number,
    required TResult Function() substract,
  }) {
    return multiply();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? add,
    TResult Function()? divide,
    TResult Function()? multiply,
    TResult Function(String value)? number,
    TResult Function()? substract,
  }) {
    return multiply?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? add,
    TResult Function()? divide,
    TResult Function()? multiply,
    TResult Function(String value)? number,
    TResult Function()? substract,
    required TResult orElse(),
  }) {
    if (multiply != null) {
      return multiply();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Add value) add,
    required TResult Function(_Divide value) divide,
    required TResult Function(_Multiply value) multiply,
    required TResult Function(_Number value) number,
    required TResult Function(_Substract value) substract,
  }) {
    return multiply(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Add value)? add,
    TResult Function(_Divide value)? divide,
    TResult Function(_Multiply value)? multiply,
    TResult Function(_Number value)? number,
    TResult Function(_Substract value)? substract,
  }) {
    return multiply?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Add value)? add,
    TResult Function(_Divide value)? divide,
    TResult Function(_Multiply value)? multiply,
    TResult Function(_Number value)? number,
    TResult Function(_Substract value)? substract,
    required TResult orElse(),
  }) {
    if (multiply != null) {
      return multiply(this);
    }
    return orElse();
  }
}

abstract class _Multiply implements CalculatorItem {
  const factory _Multiply() = _$_Multiply;
}

/// @nodoc
abstract class _$NumberCopyWith<$Res> {
  factory _$NumberCopyWith(_Number value, $Res Function(_Number) then) =
      __$NumberCopyWithImpl<$Res>;
  $Res call({String value});
}

/// @nodoc
class __$NumberCopyWithImpl<$Res> extends _$CalculatorItemCopyWithImpl<$Res>
    implements _$NumberCopyWith<$Res> {
  __$NumberCopyWithImpl(_Number _value, $Res Function(_Number) _then)
      : super(_value, (v) => _then(v as _Number));

  @override
  _Number get _value => super._value as _Number;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_Number(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_Number implements _Number {
  const _$_Number(this.value);

  @override
  final String value;

  @override
  String toString() {
    return 'CalculatorItem.number(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _Number &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  _$NumberCopyWith<_Number> get copyWith =>
      __$NumberCopyWithImpl<_Number>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() add,
    required TResult Function() divide,
    required TResult Function() multiply,
    required TResult Function(String value) number,
    required TResult Function() substract,
  }) {
    return number(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? add,
    TResult Function()? divide,
    TResult Function()? multiply,
    TResult Function(String value)? number,
    TResult Function()? substract,
  }) {
    return number?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? add,
    TResult Function()? divide,
    TResult Function()? multiply,
    TResult Function(String value)? number,
    TResult Function()? substract,
    required TResult orElse(),
  }) {
    if (number != null) {
      return number(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Add value) add,
    required TResult Function(_Divide value) divide,
    required TResult Function(_Multiply value) multiply,
    required TResult Function(_Number value) number,
    required TResult Function(_Substract value) substract,
  }) {
    return number(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Add value)? add,
    TResult Function(_Divide value)? divide,
    TResult Function(_Multiply value)? multiply,
    TResult Function(_Number value)? number,
    TResult Function(_Substract value)? substract,
  }) {
    return number?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Add value)? add,
    TResult Function(_Divide value)? divide,
    TResult Function(_Multiply value)? multiply,
    TResult Function(_Number value)? number,
    TResult Function(_Substract value)? substract,
    required TResult orElse(),
  }) {
    if (number != null) {
      return number(this);
    }
    return orElse();
  }
}

abstract class _Number implements CalculatorItem {
  const factory _Number(String value) = _$_Number;

  String get value;
  @JsonKey(ignore: true)
  _$NumberCopyWith<_Number> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$SubstractCopyWith<$Res> {
  factory _$SubstractCopyWith(
          _Substract value, $Res Function(_Substract) then) =
      __$SubstractCopyWithImpl<$Res>;
}

/// @nodoc
class __$SubstractCopyWithImpl<$Res> extends _$CalculatorItemCopyWithImpl<$Res>
    implements _$SubstractCopyWith<$Res> {
  __$SubstractCopyWithImpl(_Substract _value, $Res Function(_Substract) _then)
      : super(_value, (v) => _then(v as _Substract));

  @override
  _Substract get _value => super._value as _Substract;
}

/// @nodoc

class _$_Substract implements _Substract {
  const _$_Substract();

  @override
  String toString() {
    return 'CalculatorItem.substract()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Substract);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() add,
    required TResult Function() divide,
    required TResult Function() multiply,
    required TResult Function(String value) number,
    required TResult Function() substract,
  }) {
    return substract();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? add,
    TResult Function()? divide,
    TResult Function()? multiply,
    TResult Function(String value)? number,
    TResult Function()? substract,
  }) {
    return substract?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? add,
    TResult Function()? divide,
    TResult Function()? multiply,
    TResult Function(String value)? number,
    TResult Function()? substract,
    required TResult orElse(),
  }) {
    if (substract != null) {
      return substract();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Add value) add,
    required TResult Function(_Divide value) divide,
    required TResult Function(_Multiply value) multiply,
    required TResult Function(_Number value) number,
    required TResult Function(_Substract value) substract,
  }) {
    return substract(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Add value)? add,
    TResult Function(_Divide value)? divide,
    TResult Function(_Multiply value)? multiply,
    TResult Function(_Number value)? number,
    TResult Function(_Substract value)? substract,
  }) {
    return substract?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Add value)? add,
    TResult Function(_Divide value)? divide,
    TResult Function(_Multiply value)? multiply,
    TResult Function(_Number value)? number,
    TResult Function(_Substract value)? substract,
    required TResult orElse(),
  }) {
    if (substract != null) {
      return substract(this);
    }
    return orElse();
  }
}

abstract class _Substract implements CalculatorItem {
  const factory _Substract() = _$_Substract;
}
